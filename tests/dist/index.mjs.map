{"version":3,"file":"index.mjs","names":["module","exports","eval","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","threw","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","ab","URL","url","pathname","slice","match","base64_encodeBase64","input","Uint8Array","toBase64","CHUNK_SIZE","arr","i","length","push","String","fromCharCode","apply","subarray","btoa","join","base64_decodeBase64","encoded","fromBase64","binary","atob","bytes","charCodeAt","JOSEError","Error","static","code","constructor","message","options","super","this","name","captureStackTrace","errors_JWTClaimValidationFailed","claim","reason","payload","cause","errors_JWTExpired","JOSEAlgNotAllowed","errors_JOSENotSupported","JWEDecryptionFailed","JWEInvalid","JWSInvalid","errors_JWTInvalid","JWKInvalid","JWKSInvalid","JWKSNoMatchingKey","JWKSMultipleMatchingKeys","Symbol","asyncIterator","JWKSTimeout","JWSSignatureVerificationFailed","formatPEM","b64","descriptor","newlined","genericExport","async","keyType","keyFormat","isKeyObject","type","TypeError","export","format","isCryptoKey","invalidKeyInput","extractable","encodeBase64","crypto","subtle","exportKey","toUpperCase","toSPKI","toPKCS8","getNamedCurve","keyData","patterns","entries","maxPatternLen","Math","max","map","byteLength","curve","every","byte","idx","genericImport","alg","algorithm","keyUsages","isPublic","getSignatureUsages","getEncryptionUsages","hash","parseInt","curveMap","ES256","ES384","ES512","namedCurve","importKey","fromPKCS8","pem","replace","asn1_fromSPKI","decodeBase64","spkiFromX509","buf","pos","parseLength","first","lengthOfLength","skipElement","count","spkiStart","spkiContentLength","extractX509SPKI","x509","base64Content","derBytes","asn1_fromX509","spki","importSPKI","indexOf","fromSPKI","importX509","fromX509","importPKCS8","pkcs8","importJWK","jwk","isObject","ext","kty","k","decodeBase64URL","oth","JOSENotSupported","toCryptoKey","encoder","TextEncoder","buffer_utils_decoder","TextDecoder","MAX_INT32","concat","buffers","size","reduce","acc","buffer","set","writeUInt32BE","value","offset","RangeError","uint64be","high","floor","low","uint32be","decode","alphabet","encode","unencoded","omitPadding","subtle_dsa","saltLength","check_key_length","startsWith","modulusLength","unusable","isAlgorithm","getHashLength","crypto_key_getNamedCurve","checkUsage","usage","usages","includes","checkSigCryptoKey","expected","actual","checkEncCryptoKey","msg","types","filter","Boolean","last","pop","invalid_key_input","withAlg","get_sign_verify_key","sign","data","cryptoKey","signature","is_disjoint","headers","sources","header","parameters","keys","Set","parameter","has","add","assertCryptoKey","is_key_like_isCryptoKey","toStringTag","is_key_like_isKeyObject","is_key_like","isObjectLike","is_object","toString","getPrototypeOf","proto","isJWK","isPrivateJWK","isPublicJWK","isSecretJWK","tag","jwkMatchesOp","use","Array","isArray","key_ops","expectedKeyOp","test","endsWith","symmetricTypeCheck","asymmetricTypeCheck","check_key_type","symmetric","validate_crit","Err","recognizedDefault","recognizedOption","protectedHeader","joseHeader","crit","some","recognized","Map","subtleMapping","crv","jwk_to_key","cache","handleJWK","freeze","WeakMap","cached","handleKeyObject","keyObject","asymmetricKeyType","nist","asymmetricKeyDetails","normalize_key","err","FlattenedSign","unprotectedHeader","setProtectedHeader","setUnprotectedHeader","extensions","JSON","stringify","jws","protected","CompactSign","flattened","lib_epoch","date","getTime","minute","hour","day","week","year","REGEX","lib_secs","str","matched","exec","parseFloat","unit","toLowerCase","numericDate","round","validateInput","label","Number","isFinite","normalizeTyp","checkAudiencePresence","audPayload","audOption","bind","validateClaimsSet","encodedPayload","parse","decoder","JWTInvalid","typ","JWTClaimValidationFailed","requiredClaims","issuer","subject","audience","maxTokenAge","presenceCheck","reverse","iss","sub","aud","tolerance","clockTolerance","secs","currentDate","now","epoch","Date","iat","nbf","exp","JWTExpired","age","JWTClaimsBuilder","structuredClone","jti","SignJWT","jwt","setIssuer","setSubject","setAudience","setJti","jwtId","setNotBefore","setExpirationTime","setIssuedAt","sig","issuerId","duration","expiresIn","tokenSync","privateKey","privateKeyId","result","token","then","catch","error","kid","jwtGenCore","esm","main","console","log","esm_main"],"sources":["../../node_modules/.pnpm/@vercel+ncc@0.38.3/node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../webpack/bootstrap","../webpack/runtime/define property getters","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/compat","../../node_modules/.pnpm/jose@6.0.12/node_modules/jose/dist/webapi/lib/base64.js","../../node_modules/.pnpm/jose@6.0.12/node_modules/jose/dist/webapi/util/errors.js","../../node_modules/.pnpm/jose@6.0.12/node_modules/jose/dist/webapi/lib/asn1.js","../../node_modules/.pnpm/jose@6.0.12/node_modules/jose/dist/webapi/key/import.js","../../node_modules/.pnpm/jose@6.0.12/node_modules/jose/dist/webapi/lib/buffer_utils.js","../../node_modules/.pnpm/jose@6.0.12/node_modules/jose/dist/webapi/util/base64url.js","../../node_modules/.pnpm/jose@6.0.12/node_modules/jose/dist/webapi/lib/subtle_dsa.js","../../node_modules/.pnpm/jose@6.0.12/node_modules/jose/dist/webapi/lib/check_key_length.js","../../node_modules/.pnpm/jose@6.0.12/node_modules/jose/dist/webapi/lib/crypto_key.js","../../node_modules/.pnpm/jose@6.0.12/node_modules/jose/dist/webapi/lib/invalid_key_input.js","../../node_modules/.pnpm/jose@6.0.12/node_modules/jose/dist/webapi/lib/get_sign_verify_key.js","../../node_modules/.pnpm/jose@6.0.12/node_modules/jose/dist/webapi/lib/sign.js","../../node_modules/.pnpm/jose@6.0.12/node_modules/jose/dist/webapi/lib/is_disjoint.js","../../node_modules/.pnpm/jose@6.0.12/node_modules/jose/dist/webapi/lib/is_key_like.js","../../node_modules/.pnpm/jose@6.0.12/node_modules/jose/dist/webapi/lib/is_object.js","../../node_modules/.pnpm/jose@6.0.12/node_modules/jose/dist/webapi/lib/is_jwk.js","../../node_modules/.pnpm/jose@6.0.12/node_modules/jose/dist/webapi/lib/check_key_type.js","../../node_modules/.pnpm/jose@6.0.12/node_modules/jose/dist/webapi/lib/validate_crit.js","../../node_modules/.pnpm/jose@6.0.12/node_modules/jose/dist/webapi/lib/jwk_to_key.js","../../node_modules/.pnpm/jose@6.0.12/node_modules/jose/dist/webapi/lib/normalize_key.js","../../node_modules/.pnpm/jose@6.0.12/node_modules/jose/dist/webapi/jws/flattened/sign.js","../../node_modules/.pnpm/jose@6.0.12/node_modules/jose/dist/webapi/jws/compact/sign.js","../../node_modules/.pnpm/jose@6.0.12/node_modules/jose/dist/webapi/lib/epoch.js","../../node_modules/.pnpm/jose@6.0.12/node_modules/jose/dist/webapi/lib/secs.js","../../node_modules/.pnpm/jose@6.0.12/node_modules/jose/dist/webapi/lib/jwt_claims_set.js","../../node_modules/.pnpm/jose@6.0.12/node_modules/jose/dist/webapi/jwt/sign.js","../../package/esm/index.js","../esm/main.mjs"],"sourcesContent":[null,"// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = new URL('.', import.meta.url).pathname.slice(import.meta.url.match(/^file:\\/\\/\\/\\w:/) ? 1 : 0, -1) + \"/\";","export function encodeBase64(input) {\n    if (Uint8Array.prototype.toBase64) {\n        return input.toBase64();\n    }\n    const CHUNK_SIZE = 0x8000;\n    const arr = [];\n    for (let i = 0; i < input.length; i += CHUNK_SIZE) {\n        arr.push(String.fromCharCode.apply(null, input.subarray(i, i + CHUNK_SIZE)));\n    }\n    return btoa(arr.join(''));\n}\nexport function decodeBase64(encoded) {\n    if (Uint8Array.fromBase64) {\n        return Uint8Array.fromBase64(encoded);\n    }\n    const binary = atob(encoded);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n}\n","export class JOSEError extends Error {\n    static code = 'ERR_JOSE_GENERIC';\n    code = 'ERR_JOSE_GENERIC';\n    constructor(message, options) {\n        super(message, options);\n        this.name = this.constructor.name;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nexport class JWTClaimValidationFailed extends JOSEError {\n    static code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n    code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n    claim;\n    reason;\n    payload;\n    constructor(message, payload, claim = 'unspecified', reason = 'unspecified') {\n        super(message, { cause: { claim, reason, payload } });\n        this.claim = claim;\n        this.reason = reason;\n        this.payload = payload;\n    }\n}\nexport class JWTExpired extends JOSEError {\n    static code = 'ERR_JWT_EXPIRED';\n    code = 'ERR_JWT_EXPIRED';\n    claim;\n    reason;\n    payload;\n    constructor(message, payload, claim = 'unspecified', reason = 'unspecified') {\n        super(message, { cause: { claim, reason, payload } });\n        this.claim = claim;\n        this.reason = reason;\n        this.payload = payload;\n    }\n}\nexport class JOSEAlgNotAllowed extends JOSEError {\n    static code = 'ERR_JOSE_ALG_NOT_ALLOWED';\n    code = 'ERR_JOSE_ALG_NOT_ALLOWED';\n}\nexport class JOSENotSupported extends JOSEError {\n    static code = 'ERR_JOSE_NOT_SUPPORTED';\n    code = 'ERR_JOSE_NOT_SUPPORTED';\n}\nexport class JWEDecryptionFailed extends JOSEError {\n    static code = 'ERR_JWE_DECRYPTION_FAILED';\n    code = 'ERR_JWE_DECRYPTION_FAILED';\n    constructor(message = 'decryption operation failed', options) {\n        super(message, options);\n    }\n}\nexport class JWEInvalid extends JOSEError {\n    static code = 'ERR_JWE_INVALID';\n    code = 'ERR_JWE_INVALID';\n}\nexport class JWSInvalid extends JOSEError {\n    static code = 'ERR_JWS_INVALID';\n    code = 'ERR_JWS_INVALID';\n}\nexport class JWTInvalid extends JOSEError {\n    static code = 'ERR_JWT_INVALID';\n    code = 'ERR_JWT_INVALID';\n}\nexport class JWKInvalid extends JOSEError {\n    static code = 'ERR_JWK_INVALID';\n    code = 'ERR_JWK_INVALID';\n}\nexport class JWKSInvalid extends JOSEError {\n    static code = 'ERR_JWKS_INVALID';\n    code = 'ERR_JWKS_INVALID';\n}\nexport class JWKSNoMatchingKey extends JOSEError {\n    static code = 'ERR_JWKS_NO_MATCHING_KEY';\n    code = 'ERR_JWKS_NO_MATCHING_KEY';\n    constructor(message = 'no applicable key found in the JSON Web Key Set', options) {\n        super(message, options);\n    }\n}\nexport class JWKSMultipleMatchingKeys extends JOSEError {\n    [Symbol.asyncIterator];\n    static code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n    code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n    constructor(message = 'multiple matching keys found in the JSON Web Key Set', options) {\n        super(message, options);\n    }\n}\nexport class JWKSTimeout extends JOSEError {\n    static code = 'ERR_JWKS_TIMEOUT';\n    code = 'ERR_JWKS_TIMEOUT';\n    constructor(message = 'request timed out', options) {\n        super(message, options);\n    }\n}\nexport class JWSSignatureVerificationFailed extends JOSEError {\n    static code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n    code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n    constructor(message = 'signature verification failed', options) {\n        super(message, options);\n    }\n}\n","import invalidKeyInput from './invalid_key_input.js';\nimport { encodeBase64, decodeBase64 } from '../lib/base64.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport { isCryptoKey, isKeyObject } from './is_key_like.js';\nconst formatPEM = (b64, descriptor) => {\n    const newlined = (b64.match(/.{1,64}/g) || []).join('\\n');\n    return `-----BEGIN ${descriptor}-----\\n${newlined}\\n-----END ${descriptor}-----`;\n};\nconst genericExport = async (keyType, keyFormat, key) => {\n    if (isKeyObject(key)) {\n        if (key.type !== keyType) {\n            throw new TypeError(`key is not a ${keyType} key`);\n        }\n        return key.export({ format: 'pem', type: keyFormat });\n    }\n    if (!isCryptoKey(key)) {\n        throw new TypeError(invalidKeyInput(key, 'CryptoKey', 'KeyObject'));\n    }\n    if (!key.extractable) {\n        throw new TypeError('CryptoKey is not extractable');\n    }\n    if (key.type !== keyType) {\n        throw new TypeError(`key is not a ${keyType} key`);\n    }\n    return formatPEM(encodeBase64(new Uint8Array(await crypto.subtle.exportKey(keyFormat, key))), `${keyType.toUpperCase()} KEY`);\n};\nexport const toSPKI = (key) => {\n    return genericExport('public', 'spki', key);\n};\nexport const toPKCS8 = (key) => {\n    return genericExport('private', 'pkcs8', key);\n};\nconst getNamedCurve = (keyData) => {\n    const patterns = Object.entries({\n        'P-256': [0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07],\n        'P-384': [0x06, 0x05, 0x2b, 0x81, 0x04, 0x00, 0x22],\n        'P-521': [0x06, 0x05, 0x2b, 0x81, 0x04, 0x00, 0x23],\n    });\n    const maxPatternLen = Math.max(...patterns.map(([, bytes]) => bytes.length));\n    for (let i = 0; i <= keyData.byteLength - maxPatternLen; i++) {\n        for (const [curve, bytes] of patterns) {\n            if (i <= keyData.byteLength - bytes.length) {\n                if (keyData.subarray(i, i + bytes.length).every((byte, idx) => byte === bytes[idx])) {\n                    return curve;\n                }\n            }\n        }\n    }\n    return undefined;\n};\nconst genericImport = async (keyFormat, keyData, alg, options) => {\n    let algorithm;\n    let keyUsages;\n    const isPublic = keyFormat === 'spki';\n    const getSignatureUsages = () => (isPublic ? ['verify'] : ['sign']);\n    const getEncryptionUsages = () => isPublic ? ['encrypt', 'wrapKey'] : ['decrypt', 'unwrapKey'];\n    switch (alg) {\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n            algorithm = { name: 'RSA-PSS', hash: `SHA-${alg.slice(-3)}` };\n            keyUsages = getSignatureUsages();\n            break;\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            algorithm = { name: 'RSASSA-PKCS1-v1_5', hash: `SHA-${alg.slice(-3)}` };\n            keyUsages = getSignatureUsages();\n            break;\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512':\n            algorithm = {\n                name: 'RSA-OAEP',\n                hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`,\n            };\n            keyUsages = getEncryptionUsages();\n            break;\n        case 'ES256':\n        case 'ES384':\n        case 'ES512': {\n            const curveMap = { ES256: 'P-256', ES384: 'P-384', ES512: 'P-521' };\n            algorithm = { name: 'ECDSA', namedCurve: curveMap[alg] };\n            keyUsages = getSignatureUsages();\n            break;\n        }\n        case 'ECDH-ES':\n        case 'ECDH-ES+A128KW':\n        case 'ECDH-ES+A192KW':\n        case 'ECDH-ES+A256KW': {\n            const namedCurve = getNamedCurve(keyData);\n            algorithm = namedCurve ? { name: 'ECDH', namedCurve } : { name: 'X25519' };\n            keyUsages = isPublic ? [] : ['deriveBits'];\n            break;\n        }\n        case 'Ed25519':\n        case 'EdDSA':\n            algorithm = { name: 'Ed25519' };\n            keyUsages = getSignatureUsages();\n            break;\n        default:\n            throw new JOSENotSupported('Invalid or unsupported \"alg\" (Algorithm) value');\n    }\n    return crypto.subtle.importKey(keyFormat, keyData, algorithm, options?.extractable ?? (isPublic ? true : false), keyUsages);\n};\nexport const fromPKCS8 = (pem, alg, options) => {\n    const keyData = decodeBase64(pem.replace(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\\s)/g, ''));\n    return genericImport('pkcs8', keyData, alg, options);\n};\nexport const fromSPKI = (pem, alg, options) => {\n    const keyData = decodeBase64(pem.replace(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\\s)/g, ''));\n    return genericImport('spki', keyData, alg, options);\n};\nfunction spkiFromX509(buf) {\n    let pos = 0;\n    const parseLength = () => {\n        const first = buf[pos++];\n        if (first & 0x80) {\n            const lengthOfLength = first & 0x7f;\n            let length = 0;\n            for (let i = 0; i < lengthOfLength; i++) {\n                length = (length << 8) | buf[pos++];\n            }\n            return length;\n        }\n        return first;\n    };\n    const skipElement = (count = 1) => {\n        if (count <= 0)\n            return;\n        pos++;\n        const length = parseLength();\n        pos += length;\n        if (count > 1) {\n            skipElement(count - 1);\n        }\n    };\n    if (buf[pos++] !== 0x30)\n        throw new Error('Invalid certificate structure');\n    parseLength();\n    if (buf[pos++] !== 0x30)\n        throw new Error('Invalid tbsCertificate structure');\n    parseLength();\n    if (buf[pos] === 0xa0) {\n        skipElement(6);\n    }\n    else {\n        skipElement(5);\n    }\n    const spkiStart = pos;\n    if (buf[pos++] !== 0x30)\n        throw new Error('Invalid SPKI structure');\n    const spkiContentLength = parseLength();\n    return buf.subarray(spkiStart, spkiStart + spkiContentLength + (pos - spkiStart));\n}\nfunction extractX509SPKI(x509) {\n    const base64Content = x509.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\\s)/g, '');\n    const derBytes = decodeBase64(base64Content);\n    return spkiFromX509(derBytes);\n}\nexport const fromX509 = (pem, alg, options) => {\n    let spki;\n    try {\n        spki = extractX509SPKI(pem);\n    }\n    catch (cause) {\n        throw new TypeError('Failed to parse the X.509 certificate', { cause });\n    }\n    return genericImport('spki', spki, alg, options);\n};\n","import { decode as decodeBase64URL } from '../util/base64url.js';\nimport { fromSPKI, fromPKCS8, fromX509 } from '../lib/asn1.js';\nimport toCryptoKey from '../lib/jwk_to_key.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport isObject from '../lib/is_object.js';\nexport async function importSPKI(spki, alg, options) {\n    if (typeof spki !== 'string' || spki.indexOf('-----BEGIN PUBLIC KEY-----') !== 0) {\n        throw new TypeError('\"spki\" must be SPKI formatted string');\n    }\n    return fromSPKI(spki, alg, options);\n}\nexport async function importX509(x509, alg, options) {\n    if (typeof x509 !== 'string' || x509.indexOf('-----BEGIN CERTIFICATE-----') !== 0) {\n        throw new TypeError('\"x509\" must be X.509 formatted string');\n    }\n    return fromX509(x509, alg, options);\n}\nexport async function importPKCS8(pkcs8, alg, options) {\n    if (typeof pkcs8 !== 'string' || pkcs8.indexOf('-----BEGIN PRIVATE KEY-----') !== 0) {\n        throw new TypeError('\"pkcs8\" must be PKCS#8 formatted string');\n    }\n    return fromPKCS8(pkcs8, alg, options);\n}\nexport async function importJWK(jwk, alg, options) {\n    if (!isObject(jwk)) {\n        throw new TypeError('JWK must be an object');\n    }\n    let ext;\n    alg ??= jwk.alg;\n    ext ??= options?.extractable ?? jwk.ext;\n    switch (jwk.kty) {\n        case 'oct':\n            if (typeof jwk.k !== 'string' || !jwk.k) {\n                throw new TypeError('missing \"k\" (Key Value) Parameter value');\n            }\n            return decodeBase64URL(jwk.k);\n        case 'RSA':\n            if ('oth' in jwk && jwk.oth !== undefined) {\n                throw new JOSENotSupported('RSA JWK \"oth\" (Other Primes Info) Parameter value is not supported');\n            }\n        case 'EC':\n        case 'OKP':\n            return toCryptoKey({ ...jwk, alg, ext });\n        default:\n            throw new JOSENotSupported('Unsupported \"kty\" (Key Type) Parameter value');\n    }\n}\n","export const encoder = new TextEncoder();\nexport const decoder = new TextDecoder();\nconst MAX_INT32 = 2 ** 32;\nexport function concat(...buffers) {\n    const size = buffers.reduce((acc, { length }) => acc + length, 0);\n    const buf = new Uint8Array(size);\n    let i = 0;\n    for (const buffer of buffers) {\n        buf.set(buffer, i);\n        i += buffer.length;\n    }\n    return buf;\n}\nfunction writeUInt32BE(buf, value, offset) {\n    if (value < 0 || value >= MAX_INT32) {\n        throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);\n    }\n    buf.set([value >>> 24, value >>> 16, value >>> 8, value & 0xff], offset);\n}\nexport function uint64be(value) {\n    const high = Math.floor(value / MAX_INT32);\n    const low = value % MAX_INT32;\n    const buf = new Uint8Array(8);\n    writeUInt32BE(buf, high, 0);\n    writeUInt32BE(buf, low, 4);\n    return buf;\n}\nexport function uint32be(value) {\n    const buf = new Uint8Array(4);\n    writeUInt32BE(buf, value);\n    return buf;\n}\n","import { encoder, decoder } from '../lib/buffer_utils.js';\nimport { encodeBase64, decodeBase64 } from '../lib/base64.js';\nexport function decode(input) {\n    if (Uint8Array.fromBase64) {\n        return Uint8Array.fromBase64(typeof input === 'string' ? input : decoder.decode(input), {\n            alphabet: 'base64url',\n        });\n    }\n    let encoded = input;\n    if (encoded instanceof Uint8Array) {\n        encoded = decoder.decode(encoded);\n    }\n    encoded = encoded.replace(/-/g, '+').replace(/_/g, '/').replace(/\\s/g, '');\n    try {\n        return decodeBase64(encoded);\n    }\n    catch {\n        throw new TypeError('The input to be decoded is not correctly encoded.');\n    }\n}\nexport function encode(input) {\n    let unencoded = input;\n    if (typeof unencoded === 'string') {\n        unencoded = encoder.encode(unencoded);\n    }\n    if (Uint8Array.prototype.toBase64) {\n        return unencoded.toBase64({ alphabet: 'base64url', omitPadding: true });\n    }\n    return encodeBase64(unencoded).replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n}\n","import { JOSENotSupported } from '../util/errors.js';\nexport default (alg, algorithm) => {\n    const hash = `SHA-${alg.slice(-3)}`;\n    switch (alg) {\n        case 'HS256':\n        case 'HS384':\n        case 'HS512':\n            return { hash, name: 'HMAC' };\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n            return { hash, name: 'RSA-PSS', saltLength: parseInt(alg.slice(-3), 10) >> 3 };\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            return { hash, name: 'RSASSA-PKCS1-v1_5' };\n        case 'ES256':\n        case 'ES384':\n        case 'ES512':\n            return { hash, name: 'ECDSA', namedCurve: algorithm.namedCurve };\n        case 'Ed25519':\n        case 'EdDSA':\n            return { name: 'Ed25519' };\n        default:\n            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);\n    }\n};\n","export default (alg, key) => {\n    if (alg.startsWith('RS') || alg.startsWith('PS')) {\n        const { modulusLength } = key.algorithm;\n        if (typeof modulusLength !== 'number' || modulusLength < 2048) {\n            throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);\n        }\n    }\n};\n","function unusable(name, prop = 'algorithm.name') {\n    return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);\n}\nfunction isAlgorithm(algorithm, name) {\n    return algorithm.name === name;\n}\nfunction getHashLength(hash) {\n    return parseInt(hash.name.slice(4), 10);\n}\nfunction getNamedCurve(alg) {\n    switch (alg) {\n        case 'ES256':\n            return 'P-256';\n        case 'ES384':\n            return 'P-384';\n        case 'ES512':\n            return 'P-521';\n        default:\n            throw new Error('unreachable');\n    }\n}\nfunction checkUsage(key, usage) {\n    if (usage && !key.usages.includes(usage)) {\n        throw new TypeError(`CryptoKey does not support this operation, its usages must include ${usage}.`);\n    }\n}\nexport function checkSigCryptoKey(key, alg, usage) {\n    switch (alg) {\n        case 'HS256':\n        case 'HS384':\n        case 'HS512': {\n            if (!isAlgorithm(key.algorithm, 'HMAC'))\n                throw unusable('HMAC');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'RS256':\n        case 'RS384':\n        case 'RS512': {\n            if (!isAlgorithm(key.algorithm, 'RSASSA-PKCS1-v1_5'))\n                throw unusable('RSASSA-PKCS1-v1_5');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'PS256':\n        case 'PS384':\n        case 'PS512': {\n            if (!isAlgorithm(key.algorithm, 'RSA-PSS'))\n                throw unusable('RSA-PSS');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'Ed25519':\n        case 'EdDSA': {\n            if (!isAlgorithm(key.algorithm, 'Ed25519'))\n                throw unusable('Ed25519');\n            break;\n        }\n        case 'ES256':\n        case 'ES384':\n        case 'ES512': {\n            if (!isAlgorithm(key.algorithm, 'ECDSA'))\n                throw unusable('ECDSA');\n            const expected = getNamedCurve(alg);\n            const actual = key.algorithm.namedCurve;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.namedCurve');\n            break;\n        }\n        default:\n            throw new TypeError('CryptoKey does not support this operation');\n    }\n    checkUsage(key, usage);\n}\nexport function checkEncCryptoKey(key, alg, usage) {\n    switch (alg) {\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM': {\n            if (!isAlgorithm(key.algorithm, 'AES-GCM'))\n                throw unusable('AES-GCM');\n            const expected = parseInt(alg.slice(1, 4), 10);\n            const actual = key.algorithm.length;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.length');\n            break;\n        }\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW': {\n            if (!isAlgorithm(key.algorithm, 'AES-KW'))\n                throw unusable('AES-KW');\n            const expected = parseInt(alg.slice(1, 4), 10);\n            const actual = key.algorithm.length;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.length');\n            break;\n        }\n        case 'ECDH': {\n            switch (key.algorithm.name) {\n                case 'ECDH':\n                case 'X25519':\n                    break;\n                default:\n                    throw unusable('ECDH or X25519');\n            }\n            break;\n        }\n        case 'PBES2-HS256+A128KW':\n        case 'PBES2-HS384+A192KW':\n        case 'PBES2-HS512+A256KW':\n            if (!isAlgorithm(key.algorithm, 'PBKDF2'))\n                throw unusable('PBKDF2');\n            break;\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512': {\n            if (!isAlgorithm(key.algorithm, 'RSA-OAEP'))\n                throw unusable('RSA-OAEP');\n            const expected = parseInt(alg.slice(9), 10) || 1;\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        default:\n            throw new TypeError('CryptoKey does not support this operation');\n    }\n    checkUsage(key, usage);\n}\n","function message(msg, actual, ...types) {\n    types = types.filter(Boolean);\n    if (types.length > 2) {\n        const last = types.pop();\n        msg += `one of type ${types.join(', ')}, or ${last}.`;\n    }\n    else if (types.length === 2) {\n        msg += `one of type ${types[0]} or ${types[1]}.`;\n    }\n    else {\n        msg += `of type ${types[0]}.`;\n    }\n    if (actual == null) {\n        msg += ` Received ${actual}`;\n    }\n    else if (typeof actual === 'function' && actual.name) {\n        msg += ` Received function ${actual.name}`;\n    }\n    else if (typeof actual === 'object' && actual != null) {\n        if (actual.constructor?.name) {\n            msg += ` Received an instance of ${actual.constructor.name}`;\n        }\n    }\n    return msg;\n}\nexport default (actual, ...types) => {\n    return message('Key must be ', actual, ...types);\n};\nexport function withAlg(alg, actual, ...types) {\n    return message(`Key for the ${alg} algorithm must be `, actual, ...types);\n}\n","import { checkSigCryptoKey } from './crypto_key.js';\nimport invalidKeyInput from './invalid_key_input.js';\nexport default async (alg, key, usage) => {\n    if (key instanceof Uint8Array) {\n        if (!alg.startsWith('HS')) {\n            throw new TypeError(invalidKeyInput(key, 'CryptoKey', 'KeyObject', 'JSON Web Key'));\n        }\n        return crypto.subtle.importKey('raw', key, { hash: `SHA-${alg.slice(-3)}`, name: 'HMAC' }, false, [usage]);\n    }\n    checkSigCryptoKey(key, alg, usage);\n    return key;\n};\n","import subtleAlgorithm from './subtle_dsa.js';\nimport checkKeyLength from './check_key_length.js';\nimport getSignKey from './get_sign_verify_key.js';\nexport default async (alg, key, data) => {\n    const cryptoKey = await getSignKey(alg, key, 'sign');\n    checkKeyLength(alg, cryptoKey);\n    const signature = await crypto.subtle.sign(subtleAlgorithm(alg, cryptoKey.algorithm), cryptoKey, data);\n    return new Uint8Array(signature);\n};\n","export default (...headers) => {\n    const sources = headers.filter(Boolean);\n    if (sources.length === 0 || sources.length === 1) {\n        return true;\n    }\n    let acc;\n    for (const header of sources) {\n        const parameters = Object.keys(header);\n        if (!acc || acc.size === 0) {\n            acc = new Set(parameters);\n            continue;\n        }\n        for (const parameter of parameters) {\n            if (acc.has(parameter)) {\n                return false;\n            }\n            acc.add(parameter);\n        }\n    }\n    return true;\n};\n","export function assertCryptoKey(key) {\n    if (!isCryptoKey(key)) {\n        throw new Error('CryptoKey instance expected');\n    }\n}\nexport function isCryptoKey(key) {\n    return key?.[Symbol.toStringTag] === 'CryptoKey';\n}\nexport function isKeyObject(key) {\n    return key?.[Symbol.toStringTag] === 'KeyObject';\n}\nexport default (key) => {\n    return isCryptoKey(key) || isKeyObject(key);\n};\n","function isObjectLike(value) {\n    return typeof value === 'object' && value !== null;\n}\nexport default (input) => {\n    if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') {\n        return false;\n    }\n    if (Object.getPrototypeOf(input) === null) {\n        return true;\n    }\n    let proto = input;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(input) === proto;\n};\n","import isObject from './is_object.js';\nexport function isJWK(key) {\n    return isObject(key) && typeof key.kty === 'string';\n}\nexport function isPrivateJWK(key) {\n    return key.kty !== 'oct' && typeof key.d === 'string';\n}\nexport function isPublicJWK(key) {\n    return key.kty !== 'oct' && typeof key.d === 'undefined';\n}\nexport function isSecretJWK(key) {\n    return key.kty === 'oct' && typeof key.k === 'string';\n}\n","import { withAlg as invalidKeyInput } from './invalid_key_input.js';\nimport isKeyLike from './is_key_like.js';\nimport * as jwk from './is_jwk.js';\nconst tag = (key) => key?.[Symbol.toStringTag];\nconst jwkMatchesOp = (alg, key, usage) => {\n    if (key.use !== undefined) {\n        let expected;\n        switch (usage) {\n            case 'sign':\n            case 'verify':\n                expected = 'sig';\n                break;\n            case 'encrypt':\n            case 'decrypt':\n                expected = 'enc';\n                break;\n        }\n        if (key.use !== expected) {\n            throw new TypeError(`Invalid key for this operation, its \"use\" must be \"${expected}\" when present`);\n        }\n    }\n    if (key.alg !== undefined && key.alg !== alg) {\n        throw new TypeError(`Invalid key for this operation, its \"alg\" must be \"${alg}\" when present`);\n    }\n    if (Array.isArray(key.key_ops)) {\n        let expectedKeyOp;\n        switch (true) {\n            case usage === 'sign' || usage === 'verify':\n            case alg === 'dir':\n            case alg.includes('CBC-HS'):\n                expectedKeyOp = usage;\n                break;\n            case alg.startsWith('PBES2'):\n                expectedKeyOp = 'deriveBits';\n                break;\n            case /^A\\d{3}(?:GCM)?(?:KW)?$/.test(alg):\n                if (!alg.includes('GCM') && alg.endsWith('KW')) {\n                    expectedKeyOp = usage === 'encrypt' ? 'wrapKey' : 'unwrapKey';\n                }\n                else {\n                    expectedKeyOp = usage;\n                }\n                break;\n            case usage === 'encrypt' && alg.startsWith('RSA'):\n                expectedKeyOp = 'wrapKey';\n                break;\n            case usage === 'decrypt':\n                expectedKeyOp = alg.startsWith('RSA') ? 'unwrapKey' : 'deriveBits';\n                break;\n        }\n        if (expectedKeyOp && key.key_ops?.includes?.(expectedKeyOp) === false) {\n            throw new TypeError(`Invalid key for this operation, its \"key_ops\" must include \"${expectedKeyOp}\" when present`);\n        }\n    }\n    return true;\n};\nconst symmetricTypeCheck = (alg, key, usage) => {\n    if (key instanceof Uint8Array)\n        return;\n    if (jwk.isJWK(key)) {\n        if (jwk.isSecretJWK(key) && jwkMatchesOp(alg, key, usage))\n            return;\n        throw new TypeError(`JSON Web Key for symmetric algorithms must have JWK \"kty\" (Key Type) equal to \"oct\" and the JWK \"k\" (Key Value) present`);\n    }\n    if (!isKeyLike(key)) {\n        throw new TypeError(invalidKeyInput(alg, key, 'CryptoKey', 'KeyObject', 'JSON Web Key', 'Uint8Array'));\n    }\n    if (key.type !== 'secret') {\n        throw new TypeError(`${tag(key)} instances for symmetric algorithms must be of type \"secret\"`);\n    }\n};\nconst asymmetricTypeCheck = (alg, key, usage) => {\n    if (jwk.isJWK(key)) {\n        switch (usage) {\n            case 'decrypt':\n            case 'sign':\n                if (jwk.isPrivateJWK(key) && jwkMatchesOp(alg, key, usage))\n                    return;\n                throw new TypeError(`JSON Web Key for this operation be a private JWK`);\n            case 'encrypt':\n            case 'verify':\n                if (jwk.isPublicJWK(key) && jwkMatchesOp(alg, key, usage))\n                    return;\n                throw new TypeError(`JSON Web Key for this operation be a public JWK`);\n        }\n    }\n    if (!isKeyLike(key)) {\n        throw new TypeError(invalidKeyInput(alg, key, 'CryptoKey', 'KeyObject', 'JSON Web Key'));\n    }\n    if (key.type === 'secret') {\n        throw new TypeError(`${tag(key)} instances for asymmetric algorithms must not be of type \"secret\"`);\n    }\n    if (key.type === 'public') {\n        switch (usage) {\n            case 'sign':\n                throw new TypeError(`${tag(key)} instances for asymmetric algorithm signing must be of type \"private\"`);\n            case 'decrypt':\n                throw new TypeError(`${tag(key)} instances for asymmetric algorithm decryption must be of type \"private\"`);\n            default:\n                break;\n        }\n    }\n    if (key.type === 'private') {\n        switch (usage) {\n            case 'verify':\n                throw new TypeError(`${tag(key)} instances for asymmetric algorithm verifying must be of type \"public\"`);\n            case 'encrypt':\n                throw new TypeError(`${tag(key)} instances for asymmetric algorithm encryption must be of type \"public\"`);\n            default:\n                break;\n        }\n    }\n};\nexport default (alg, key, usage) => {\n    const symmetric = alg.startsWith('HS') ||\n        alg === 'dir' ||\n        alg.startsWith('PBES2') ||\n        /^A(?:128|192|256)(?:GCM)?(?:KW)?$/.test(alg) ||\n        /^A(?:128|192|256)CBC-HS(?:256|384|512)$/.test(alg);\n    if (symmetric) {\n        symmetricTypeCheck(alg, key, usage);\n    }\n    else {\n        asymmetricTypeCheck(alg, key, usage);\n    }\n};\n","import { JOSENotSupported, JWEInvalid, JWSInvalid } from '../util/errors.js';\nexport default (Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) => {\n    if (joseHeader.crit !== undefined && protectedHeader?.crit === undefined) {\n        throw new Err('\"crit\" (Critical) Header Parameter MUST be integrity protected');\n    }\n    if (!protectedHeader || protectedHeader.crit === undefined) {\n        return new Set();\n    }\n    if (!Array.isArray(protectedHeader.crit) ||\n        protectedHeader.crit.length === 0 ||\n        protectedHeader.crit.some((input) => typeof input !== 'string' || input.length === 0)) {\n        throw new Err('\"crit\" (Critical) Header Parameter MUST be an array of non-empty strings when present');\n    }\n    let recognized;\n    if (recognizedOption !== undefined) {\n        recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);\n    }\n    else {\n        recognized = recognizedDefault;\n    }\n    for (const parameter of protectedHeader.crit) {\n        if (!recognized.has(parameter)) {\n            throw new JOSENotSupported(`Extension Header Parameter \"${parameter}\" is not recognized`);\n        }\n        if (joseHeader[parameter] === undefined) {\n            throw new Err(`Extension Header Parameter \"${parameter}\" is missing`);\n        }\n        if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {\n            throw new Err(`Extension Header Parameter \"${parameter}\" MUST be integrity protected`);\n        }\n    }\n    return new Set(protectedHeader.crit);\n};\n","import { JOSENotSupported } from '../util/errors.js';\nfunction subtleMapping(jwk) {\n    let algorithm;\n    let keyUsages;\n    switch (jwk.kty) {\n        case 'RSA': {\n            switch (jwk.alg) {\n                case 'PS256':\n                case 'PS384':\n                case 'PS512':\n                    algorithm = { name: 'RSA-PSS', hash: `SHA-${jwk.alg.slice(-3)}` };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'RS256':\n                case 'RS384':\n                case 'RS512':\n                    algorithm = { name: 'RSASSA-PKCS1-v1_5', hash: `SHA-${jwk.alg.slice(-3)}` };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'RSA-OAEP':\n                case 'RSA-OAEP-256':\n                case 'RSA-OAEP-384':\n                case 'RSA-OAEP-512':\n                    algorithm = {\n                        name: 'RSA-OAEP',\n                        hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`,\n                    };\n                    keyUsages = jwk.d ? ['decrypt', 'unwrapKey'] : ['encrypt', 'wrapKey'];\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        case 'EC': {\n            switch (jwk.alg) {\n                case 'ES256':\n                    algorithm = { name: 'ECDSA', namedCurve: 'P-256' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ES384':\n                    algorithm = { name: 'ECDSA', namedCurve: 'P-384' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ES512':\n                    algorithm = { name: 'ECDSA', namedCurve: 'P-521' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ECDH-ES':\n                case 'ECDH-ES+A128KW':\n                case 'ECDH-ES+A192KW':\n                case 'ECDH-ES+A256KW':\n                    algorithm = { name: 'ECDH', namedCurve: jwk.crv };\n                    keyUsages = jwk.d ? ['deriveBits'] : [];\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        case 'OKP': {\n            switch (jwk.alg) {\n                case 'Ed25519':\n                case 'EdDSA':\n                    algorithm = { name: 'Ed25519' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ECDH-ES':\n                case 'ECDH-ES+A128KW':\n                case 'ECDH-ES+A192KW':\n                case 'ECDH-ES+A256KW':\n                    algorithm = { name: jwk.crv };\n                    keyUsages = jwk.d ? ['deriveBits'] : [];\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        default:\n            throw new JOSENotSupported('Invalid or unsupported JWK \"kty\" (Key Type) Parameter value');\n    }\n    return { algorithm, keyUsages };\n}\nexport default async (jwk) => {\n    if (!jwk.alg) {\n        throw new TypeError('\"alg\" argument is required when \"jwk.alg\" is not present');\n    }\n    const { algorithm, keyUsages } = subtleMapping(jwk);\n    const keyData = { ...jwk };\n    delete keyData.alg;\n    delete keyData.use;\n    return crypto.subtle.importKey('jwk', keyData, algorithm, jwk.ext ?? (jwk.d ? false : true), jwk.key_ops ?? keyUsages);\n};\n","import { isJWK } from './is_jwk.js';\nimport { decode } from '../util/base64url.js';\nimport importJWK from './jwk_to_key.js';\nimport { isCryptoKey, isKeyObject } from './is_key_like.js';\nlet cache;\nconst handleJWK = async (key, jwk, alg, freeze = false) => {\n    cache ||= new WeakMap();\n    let cached = cache.get(key);\n    if (cached?.[alg]) {\n        return cached[alg];\n    }\n    const cryptoKey = await importJWK({ ...jwk, alg });\n    if (freeze)\n        Object.freeze(key);\n    if (!cached) {\n        cache.set(key, { [alg]: cryptoKey });\n    }\n    else {\n        cached[alg] = cryptoKey;\n    }\n    return cryptoKey;\n};\nconst handleKeyObject = (keyObject, alg) => {\n    cache ||= new WeakMap();\n    let cached = cache.get(keyObject);\n    if (cached?.[alg]) {\n        return cached[alg];\n    }\n    const isPublic = keyObject.type === 'public';\n    const extractable = isPublic ? true : false;\n    let cryptoKey;\n    if (keyObject.asymmetricKeyType === 'x25519') {\n        switch (alg) {\n            case 'ECDH-ES':\n            case 'ECDH-ES+A128KW':\n            case 'ECDH-ES+A192KW':\n            case 'ECDH-ES+A256KW':\n                break;\n            default:\n                throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n        }\n        cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, isPublic ? [] : ['deriveBits']);\n    }\n    if (keyObject.asymmetricKeyType === 'ed25519') {\n        if (alg !== 'EdDSA' && alg !== 'Ed25519') {\n            throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n        }\n        cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, [\n            isPublic ? 'verify' : 'sign',\n        ]);\n    }\n    if (keyObject.asymmetricKeyType === 'rsa') {\n        let hash;\n        switch (alg) {\n            case 'RSA-OAEP':\n                hash = 'SHA-1';\n                break;\n            case 'RS256':\n            case 'PS256':\n            case 'RSA-OAEP-256':\n                hash = 'SHA-256';\n                break;\n            case 'RS384':\n            case 'PS384':\n            case 'RSA-OAEP-384':\n                hash = 'SHA-384';\n                break;\n            case 'RS512':\n            case 'PS512':\n            case 'RSA-OAEP-512':\n                hash = 'SHA-512';\n                break;\n            default:\n                throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n        }\n        if (alg.startsWith('RSA-OAEP')) {\n            return keyObject.toCryptoKey({\n                name: 'RSA-OAEP',\n                hash,\n            }, extractable, isPublic ? ['encrypt'] : ['decrypt']);\n        }\n        cryptoKey = keyObject.toCryptoKey({\n            name: alg.startsWith('PS') ? 'RSA-PSS' : 'RSASSA-PKCS1-v1_5',\n            hash,\n        }, extractable, [isPublic ? 'verify' : 'sign']);\n    }\n    if (keyObject.asymmetricKeyType === 'ec') {\n        const nist = new Map([\n            ['prime256v1', 'P-256'],\n            ['secp384r1', 'P-384'],\n            ['secp521r1', 'P-521'],\n        ]);\n        const namedCurve = nist.get(keyObject.asymmetricKeyDetails?.namedCurve);\n        if (!namedCurve) {\n            throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n        }\n        if (alg === 'ES256' && namedCurve === 'P-256') {\n            cryptoKey = keyObject.toCryptoKey({\n                name: 'ECDSA',\n                namedCurve,\n            }, extractable, [isPublic ? 'verify' : 'sign']);\n        }\n        if (alg === 'ES384' && namedCurve === 'P-384') {\n            cryptoKey = keyObject.toCryptoKey({\n                name: 'ECDSA',\n                namedCurve,\n            }, extractable, [isPublic ? 'verify' : 'sign']);\n        }\n        if (alg === 'ES512' && namedCurve === 'P-521') {\n            cryptoKey = keyObject.toCryptoKey({\n                name: 'ECDSA',\n                namedCurve,\n            }, extractable, [isPublic ? 'verify' : 'sign']);\n        }\n        if (alg.startsWith('ECDH-ES')) {\n            cryptoKey = keyObject.toCryptoKey({\n                name: 'ECDH',\n                namedCurve,\n            }, extractable, isPublic ? [] : ['deriveBits']);\n        }\n    }\n    if (!cryptoKey) {\n        throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n    }\n    if (!cached) {\n        cache.set(keyObject, { [alg]: cryptoKey });\n    }\n    else {\n        cached[alg] = cryptoKey;\n    }\n    return cryptoKey;\n};\nexport default async (key, alg) => {\n    if (key instanceof Uint8Array) {\n        return key;\n    }\n    if (isCryptoKey(key)) {\n        return key;\n    }\n    if (isKeyObject(key)) {\n        if (key.type === 'secret') {\n            return key.export();\n        }\n        if ('toCryptoKey' in key && typeof key.toCryptoKey === 'function') {\n            try {\n                return handleKeyObject(key, alg);\n            }\n            catch (err) {\n                if (err instanceof TypeError) {\n                    throw err;\n                }\n            }\n        }\n        let jwk = key.export({ format: 'jwk' });\n        return handleJWK(key, jwk, alg);\n    }\n    if (isJWK(key)) {\n        if (key.k) {\n            return decode(key.k);\n        }\n        return handleJWK(key, key, alg, true);\n    }\n    throw new Error('unreachable');\n};\n","import { encode as b64u } from '../../util/base64url.js';\nimport sign from '../../lib/sign.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport { JWSInvalid } from '../../util/errors.js';\nimport { encoder, decoder, concat } from '../../lib/buffer_utils.js';\nimport checkKeyType from '../../lib/check_key_type.js';\nimport validateCrit from '../../lib/validate_crit.js';\nimport normalizeKey from '../../lib/normalize_key.js';\nexport class FlattenedSign {\n    #payload;\n    #protectedHeader;\n    #unprotectedHeader;\n    constructor(payload) {\n        if (!(payload instanceof Uint8Array)) {\n            throw new TypeError('payload must be an instance of Uint8Array');\n        }\n        this.#payload = payload;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this.#protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this.#protectedHeader = protectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this.#unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this.#unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        if (!this.#protectedHeader && !this.#unprotectedHeader) {\n            throw new JWSInvalid('either setProtectedHeader or setUnprotectedHeader must be called before #sign()');\n        }\n        if (!isDisjoint(this.#protectedHeader, this.#unprotectedHeader)) {\n            throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n        }\n        const joseHeader = {\n            ...this.#protectedHeader,\n            ...this.#unprotectedHeader,\n        };\n        const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options?.crit, this.#protectedHeader, joseHeader);\n        let b64 = true;\n        if (extensions.has('b64')) {\n            b64 = this.#protectedHeader.b64;\n            if (typeof b64 !== 'boolean') {\n                throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n            }\n        }\n        const { alg } = joseHeader;\n        if (typeof alg !== 'string' || !alg) {\n            throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n        }\n        checkKeyType(alg, key, 'sign');\n        let payload = this.#payload;\n        if (b64) {\n            payload = encoder.encode(b64u(payload));\n        }\n        let protectedHeader;\n        if (this.#protectedHeader) {\n            protectedHeader = encoder.encode(b64u(JSON.stringify(this.#protectedHeader)));\n        }\n        else {\n            protectedHeader = encoder.encode('');\n        }\n        const data = concat(protectedHeader, encoder.encode('.'), payload);\n        const k = await normalizeKey(key, alg);\n        const signature = await sign(alg, k, data);\n        const jws = {\n            signature: b64u(signature),\n            payload: '',\n        };\n        if (b64) {\n            jws.payload = decoder.decode(payload);\n        }\n        if (this.#unprotectedHeader) {\n            jws.header = this.#unprotectedHeader;\n        }\n        if (this.#protectedHeader) {\n            jws.protected = decoder.decode(protectedHeader);\n        }\n        return jws;\n    }\n}\n","import { FlattenedSign } from '../flattened/sign.js';\nexport class CompactSign {\n    #flattened;\n    constructor(payload) {\n        this.#flattened = new FlattenedSign(payload);\n    }\n    setProtectedHeader(protectedHeader) {\n        this.#flattened.setProtectedHeader(protectedHeader);\n        return this;\n    }\n    async sign(key, options) {\n        const jws = await this.#flattened.sign(key, options);\n        if (jws.payload === undefined) {\n            throw new TypeError('use the flattened module for creating JWS with b64: false');\n        }\n        return `${jws.protected}.${jws.payload}.${jws.signature}`;\n    }\n}\n","export default (date) => Math.floor(date.getTime() / 1000);\n","const minute = 60;\nconst hour = minute * 60;\nconst day = hour * 24;\nconst week = day * 7;\nconst year = day * 365.25;\nconst REGEX = /^(\\+|\\-)? ?(\\d+|\\d+\\.\\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;\nexport default (str) => {\n    const matched = REGEX.exec(str);\n    if (!matched || (matched[4] && matched[1])) {\n        throw new TypeError('Invalid time period format');\n    }\n    const value = parseFloat(matched[2]);\n    const unit = matched[3].toLowerCase();\n    let numericDate;\n    switch (unit) {\n        case 'sec':\n        case 'secs':\n        case 'second':\n        case 'seconds':\n        case 's':\n            numericDate = Math.round(value);\n            break;\n        case 'minute':\n        case 'minutes':\n        case 'min':\n        case 'mins':\n        case 'm':\n            numericDate = Math.round(value * minute);\n            break;\n        case 'hour':\n        case 'hours':\n        case 'hr':\n        case 'hrs':\n        case 'h':\n            numericDate = Math.round(value * hour);\n            break;\n        case 'day':\n        case 'days':\n        case 'd':\n            numericDate = Math.round(value * day);\n            break;\n        case 'week':\n        case 'weeks':\n        case 'w':\n            numericDate = Math.round(value * week);\n            break;\n        default:\n            numericDate = Math.round(value * year);\n            break;\n    }\n    if (matched[1] === '-' || matched[4] === 'ago') {\n        return -numericDate;\n    }\n    return numericDate;\n};\n","import { JWTClaimValidationFailed, JWTExpired, JWTInvalid } from '../util/errors.js';\nimport { decoder } from './buffer_utils.js';\nimport epoch from './epoch.js';\nimport secs from './secs.js';\nimport isObject from './is_object.js';\nimport { encoder } from './buffer_utils.js';\nfunction validateInput(label, input) {\n    if (!Number.isFinite(input)) {\n        throw new TypeError(`Invalid ${label} input`);\n    }\n    return input;\n}\nconst normalizeTyp = (value) => {\n    if (value.includes('/')) {\n        return value.toLowerCase();\n    }\n    return `application/${value.toLowerCase()}`;\n};\nconst checkAudiencePresence = (audPayload, audOption) => {\n    if (typeof audPayload === 'string') {\n        return audOption.includes(audPayload);\n    }\n    if (Array.isArray(audPayload)) {\n        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));\n    }\n    return false;\n};\nexport function validateClaimsSet(protectedHeader, encodedPayload, options = {}) {\n    let payload;\n    try {\n        payload = JSON.parse(decoder.decode(encodedPayload));\n    }\n    catch {\n    }\n    if (!isObject(payload)) {\n        throw new JWTInvalid('JWT Claims Set must be a top-level JSON object');\n    }\n    const { typ } = options;\n    if (typ &&\n        (typeof protectedHeader.typ !== 'string' ||\n            normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {\n        throw new JWTClaimValidationFailed('unexpected \"typ\" JWT header value', payload, 'typ', 'check_failed');\n    }\n    const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;\n    const presenceCheck = [...requiredClaims];\n    if (maxTokenAge !== undefined)\n        presenceCheck.push('iat');\n    if (audience !== undefined)\n        presenceCheck.push('aud');\n    if (subject !== undefined)\n        presenceCheck.push('sub');\n    if (issuer !== undefined)\n        presenceCheck.push('iss');\n    for (const claim of new Set(presenceCheck.reverse())) {\n        if (!(claim in payload)) {\n            throw new JWTClaimValidationFailed(`missing required \"${claim}\" claim`, payload, claim, 'missing');\n        }\n    }\n    if (issuer &&\n        !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {\n        throw new JWTClaimValidationFailed('unexpected \"iss\" claim value', payload, 'iss', 'check_failed');\n    }\n    if (subject && payload.sub !== subject) {\n        throw new JWTClaimValidationFailed('unexpected \"sub\" claim value', payload, 'sub', 'check_failed');\n    }\n    if (audience &&\n        !checkAudiencePresence(payload.aud, typeof audience === 'string' ? [audience] : audience)) {\n        throw new JWTClaimValidationFailed('unexpected \"aud\" claim value', payload, 'aud', 'check_failed');\n    }\n    let tolerance;\n    switch (typeof options.clockTolerance) {\n        case 'string':\n            tolerance = secs(options.clockTolerance);\n            break;\n        case 'number':\n            tolerance = options.clockTolerance;\n            break;\n        case 'undefined':\n            tolerance = 0;\n            break;\n        default:\n            throw new TypeError('Invalid clockTolerance option type');\n    }\n    const { currentDate } = options;\n    const now = epoch(currentDate || new Date());\n    if ((payload.iat !== undefined || maxTokenAge) && typeof payload.iat !== 'number') {\n        throw new JWTClaimValidationFailed('\"iat\" claim must be a number', payload, 'iat', 'invalid');\n    }\n    if (payload.nbf !== undefined) {\n        if (typeof payload.nbf !== 'number') {\n            throw new JWTClaimValidationFailed('\"nbf\" claim must be a number', payload, 'nbf', 'invalid');\n        }\n        if (payload.nbf > now + tolerance) {\n            throw new JWTClaimValidationFailed('\"nbf\" claim timestamp check failed', payload, 'nbf', 'check_failed');\n        }\n    }\n    if (payload.exp !== undefined) {\n        if (typeof payload.exp !== 'number') {\n            throw new JWTClaimValidationFailed('\"exp\" claim must be a number', payload, 'exp', 'invalid');\n        }\n        if (payload.exp <= now - tolerance) {\n            throw new JWTExpired('\"exp\" claim timestamp check failed', payload, 'exp', 'check_failed');\n        }\n    }\n    if (maxTokenAge) {\n        const age = now - payload.iat;\n        const max = typeof maxTokenAge === 'number' ? maxTokenAge : secs(maxTokenAge);\n        if (age - tolerance > max) {\n            throw new JWTExpired('\"iat\" claim timestamp check failed (too far in the past)', payload, 'iat', 'check_failed');\n        }\n        if (age < 0 - tolerance) {\n            throw new JWTClaimValidationFailed('\"iat\" claim timestamp check failed (it should be in the past)', payload, 'iat', 'check_failed');\n        }\n    }\n    return payload;\n}\nexport class JWTClaimsBuilder {\n    #payload;\n    constructor(payload) {\n        if (!isObject(payload)) {\n            throw new TypeError('JWT Claims Set MUST be an object');\n        }\n        this.#payload = structuredClone(payload);\n    }\n    data() {\n        return encoder.encode(JSON.stringify(this.#payload));\n    }\n    get iss() {\n        return this.#payload.iss;\n    }\n    set iss(value) {\n        this.#payload.iss = value;\n    }\n    get sub() {\n        return this.#payload.sub;\n    }\n    set sub(value) {\n        this.#payload.sub = value;\n    }\n    get aud() {\n        return this.#payload.aud;\n    }\n    set aud(value) {\n        this.#payload.aud = value;\n    }\n    set jti(value) {\n        this.#payload.jti = value;\n    }\n    set nbf(value) {\n        if (typeof value === 'number') {\n            this.#payload.nbf = validateInput('setNotBefore', value);\n        }\n        else if (value instanceof Date) {\n            this.#payload.nbf = validateInput('setNotBefore', epoch(value));\n        }\n        else {\n            this.#payload.nbf = epoch(new Date()) + secs(value);\n        }\n    }\n    set exp(value) {\n        if (typeof value === 'number') {\n            this.#payload.exp = validateInput('setExpirationTime', value);\n        }\n        else if (value instanceof Date) {\n            this.#payload.exp = validateInput('setExpirationTime', epoch(value));\n        }\n        else {\n            this.#payload.exp = epoch(new Date()) + secs(value);\n        }\n    }\n    set iat(value) {\n        if (typeof value === 'undefined') {\n            this.#payload.iat = epoch(new Date());\n        }\n        else if (value instanceof Date) {\n            this.#payload.iat = validateInput('setIssuedAt', epoch(value));\n        }\n        else if (typeof value === 'string') {\n            this.#payload.iat = validateInput('setIssuedAt', epoch(new Date()) + secs(value));\n        }\n        else {\n            this.#payload.iat = validateInput('setIssuedAt', value);\n        }\n    }\n}\n","import { CompactSign } from '../jws/compact/sign.js';\nimport { JWTInvalid } from '../util/errors.js';\nimport { JWTClaimsBuilder } from '../lib/jwt_claims_set.js';\nexport class SignJWT {\n    #protectedHeader;\n    #jwt;\n    constructor(payload = {}) {\n        this.#jwt = new JWTClaimsBuilder(payload);\n    }\n    setIssuer(issuer) {\n        this.#jwt.iss = issuer;\n        return this;\n    }\n    setSubject(subject) {\n        this.#jwt.sub = subject;\n        return this;\n    }\n    setAudience(audience) {\n        this.#jwt.aud = audience;\n        return this;\n    }\n    setJti(jwtId) {\n        this.#jwt.jti = jwtId;\n        return this;\n    }\n    setNotBefore(input) {\n        this.#jwt.nbf = input;\n        return this;\n    }\n    setExpirationTime(input) {\n        this.#jwt.exp = input;\n        return this;\n    }\n    setIssuedAt(input) {\n        this.#jwt.iat = input;\n        return this;\n    }\n    setProtectedHeader(protectedHeader) {\n        this.#protectedHeader = protectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        const sig = new CompactSign(this.#jwt.data());\n        sig.setProtectedHeader(this.#protectedHeader);\n        if (Array.isArray(this.#protectedHeader?.crit) &&\n            this.#protectedHeader.crit.includes('b64') &&\n            this.#protectedHeader.b64 === false) {\n            throw new JWTInvalid('JWTs MUST NOT use unencoded payload');\n        }\n        return sig.sign(key, options);\n    }\n}\n","import { SignJWT, importPKCS8 } from 'jose';\nconst payload = (issuerId, duration)=>({\n        audience: 'appstoreconnect-v1',\n        expiresIn: duration,\n        issuer: issuerId\n    });\n/**\n * Synchronous token generation.\n * @deprecated Use `token` instead.\n * \n * @param privateKey\n * @param issuerId \n * @param privateKeyId \n * @param duration \n * @returns \n */ export function tokenSync(privateKey, issuerId, privateKeyId, duration = 500) {\n    let result;\n    token(privateKey, issuerId, privateKeyId, duration).then((token)=>{\n        result = token;\n        return token;\n    }).catch((error)=>{\n        throw new Error(`Failed to generate token: ${error.message}`);\n    });\n    return result ?? '';\n}\n/**\n * Asynchronous token generation.\n * @param privateKey \n * @param issuerId \n * @param privateKeyId \n * @param duration \n * @returns \n */ export async function token(privateKey, issuerId, privateKeyId, duration = 500) {\n    const key = await importPKCS8(privateKey.toString(), 'ES256');\n    return new SignJWT(payload(issuerId, duration)).setProtectedHeader({\n        alg: 'ES256',\n        kid: privateKeyId\n    }).sign(key);\n}\nconst jwtGenCore = {\n    tokenSync,\n    token\n};\nexport default jwtGenCore;\n\n\n//# sourceMappingURL=index.js.map","import { token } from 'appstore-connect-jwt-generator-core';\nimport 'source-map-support/register';\nconst main = {\n    main: () => {\n        console.log(typeof token);\n    }\n};\nexport default main;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5tanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvbWFpbi5tdHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLHFDQUFxQyxDQUFDO0FBQzVELE9BQU8sNkJBQTZCLENBQUM7QUFFckMsTUFBTSxJQUFJLEdBQUc7SUFDVCxJQUFJLEVBQUUsR0FBRyxFQUFFO1FBQ1AsT0FBTyxDQUFDLEdBQUcsQ0FBQyxPQUFPLEtBQUssQ0FBQyxDQUFDO0lBQzlCLENBQUM7Q0FDSixDQUFDO0FBRUYsZUFBZSxJQUFJLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB0b2tlbiB9IGZyb20gJ2FwcHN0b3JlLWNvbm5lY3Qtand0LWdlbmVyYXRvci1jb3JlJztcbmltcG9ydCAnc291cmNlLW1hcC1zdXBwb3J0L3JlZ2lzdGVyJztcblxuY29uc3QgbWFpbiA9IHtcbiAgICBtYWluOiAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKHR5cGVvZiB0b2tlbik7XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgbWFpbjsiXX0="],"mappings":"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","ignoreList":[]}