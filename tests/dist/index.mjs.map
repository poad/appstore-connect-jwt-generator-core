{"version":3,"file":"index.mjs","names":["module","exports","eval","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","threw","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","ab","URL","url","pathname","slice","match","base64_encodeBase64","input","Uint8Array","toBase64","CHUNK_SIZE","arr","i","length","push","String","fromCharCode","apply","subarray","btoa","join","decodeBase64","encoded","fromBase64","binary","atob","bytes","charCodeAt","JOSEError","Error","static","code","constructor","message","options","super","this","name","captureStackTrace","errors_JWTClaimValidationFailed","claim","reason","payload","cause","errors_JWTExpired","JOSEAlgNotAllowed","errors_JOSENotSupported","JWEDecryptionFailed","JWEInvalid","JWSInvalid","errors_JWTInvalid","JWKInvalid","JWKSInvalid","JWKSNoMatchingKey","JWKSMultipleMatchingKeys","Symbol","asyncIterator","JWKSTimeout","JWSSignatureVerificationFailed","formatPEM","b64","descriptor","newlined","genericExport","async","keyType","keyFormat","isKeyObject","type","TypeError","export","format","isCryptoKey","invalidKeyInput","extractable","encodeBase64","crypto","subtle","exportKey","toUpperCase","toSPKI","toPKCS8","bytesEqual","a","b","byteLength","createASN1State","data","pos","parseLength","state","first","lengthOfLen","skipElement","count","expectTag","expectedTag","errorMessage","getSubarray","result","parseAlgorithmOID","oidLen","parsePKCS8Header","verLen","algIdLen","algIdStart","algIdLength","parseSPKIHeader","parseECAlgorithmIdentifier","algOid","curveOidLen","curveOid","oid","genericImport","keyData","alg","algorithm","keyUsages","isPublic","getSigUsages","getEncUsages","hash","parseInt","curveMap","ES256","ES384","ES512","namedCurve","getNamedCurve","importKey","processPEMData","pem","pattern","replace","fromPKCS8","opts","startsWith","asn1_fromSPKI","spkiFromX509","buf","spkiStart","spkiContentLen","extractX509SPKI","x509","derBytes","asn1_fromX509","spki","importSPKI","indexOf","fromSPKI","importX509","fromX509","importPKCS8","pkcs8","importJWK","jwk","isObject","ext","kty","k","decodeBase64URL","oth","JOSENotSupported","jwkToKey","encoder","TextEncoder","buffer_utils_decoder","TextDecoder","MAX_INT32","concat","buffers","size","reduce","acc","buffer","set","writeUInt32BE","value","offset","RangeError","uint64be","high","Math","floor","low","uint32be","encode","string","decode","alphabet","base64url_encode","unencoded","omitPadding","subtleAlgorithm","saltLength","checkKeyLength","modulusLength","unusable","isAlgorithm","getHashLength","checkUsage","usage","usages","includes","checkSigCryptoKey","expected","actual","checkEncCryptoKey","msg","types","filter","Boolean","last","pop","invalid_key_input_invalidKeyInput","withAlg","getSigKey","sign","cryptoKey","signature","isDisjoint","headers","sources","header","parameters","keys","Set","parameter","has","add","assertCryptoKey","is_key_like_isCryptoKey","toStringTag","CryptoKey","is_key_like_isKeyObject","isKeyLike","isObjectLike","is_object_isObject","toString","getPrototypeOf","proto","isJWK","isPrivateJWK","priv","isPublicJWK","isSecretJWK","tag","jwkMatchesOp","use","Array","isArray","key_ops","expectedKeyOp","test","endsWith","symmetricTypeCheck","asymmetricTypeCheck","checkKeyType","substring","validateCrit","Err","recognizedDefault","recognizedOption","protectedHeader","joseHeader","crit","some","recognized","Map","entries","subtleMapping","crv","jwk_to_key_jwkToKey","cache","handleJWK","freeze","WeakMap","cached","handleKeyObject","keyObject","asymmetricKeyType","toCryptoKey","nist","asymmetricKeyDetails","normalizeKey","err","FlattenedSign","unprotectedHeader","setProtectedHeader","setUnprotectedHeader","extensions","payloadS","payloadB","protectedHeaderString","protectedHeaderBytes","JSON","stringify","jws","protected","CompactSign","flattened","epoch","date","getTime","minute","hour","day","week","year","REGEX","secs","str","matched","exec","parseFloat","unit","toLowerCase","numericDate","round","validateInput","label","Number","isFinite","normalizeTyp","checkAudiencePresence","audPayload","audOption","bind","validateClaimsSet","encodedPayload","parse","decoder","JWTInvalid","typ","JWTClaimValidationFailed","requiredClaims","issuer","subject","audience","maxTokenAge","presenceCheck","reverse","iss","sub","aud","tolerance","clockTolerance","currentDate","now","Date","iat","nbf","exp","JWTExpired","age","max","JWTClaimsBuilder","structuredClone","jti","SignJWT","jwt","setIssuer","setSubject","setAudience","setJti","jwtId","setNotBefore","setExpirationTime","setIssuedAt","sig","issuerId","duration","expiresIn","tokenSync","privateKey","privateKeyId","token","then","catch","error","kid","jwtGenCore","esm","main","console","log","esm_main"],"sources":["../../node_modules/.pnpm/@vercel+ncc@0.38.4/node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../webpack/bootstrap","../webpack/runtime/define property getters","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/compat","../../node_modules/.pnpm/jose@6.1.2/node_modules/jose/dist/webapi/lib/base64.js","../../node_modules/.pnpm/jose@6.1.2/node_modules/jose/dist/webapi/util/errors.js","../../node_modules/.pnpm/jose@6.1.2/node_modules/jose/dist/webapi/lib/asn1.js","../../node_modules/.pnpm/jose@6.1.2/node_modules/jose/dist/webapi/key/import.js","../../node_modules/.pnpm/jose@6.1.2/node_modules/jose/dist/webapi/lib/buffer_utils.js","../../node_modules/.pnpm/jose@6.1.2/node_modules/jose/dist/webapi/util/base64url.js","../../node_modules/.pnpm/jose@6.1.2/node_modules/jose/dist/webapi/lib/subtle_dsa.js","../../node_modules/.pnpm/jose@6.1.2/node_modules/jose/dist/webapi/lib/check_key_length.js","../../node_modules/.pnpm/jose@6.1.2/node_modules/jose/dist/webapi/lib/crypto_key.js","../../node_modules/.pnpm/jose@6.1.2/node_modules/jose/dist/webapi/lib/invalid_key_input.js","../../node_modules/.pnpm/jose@6.1.2/node_modules/jose/dist/webapi/lib/get_sign_verify_key.js","../../node_modules/.pnpm/jose@6.1.2/node_modules/jose/dist/webapi/lib/sign.js","../../node_modules/.pnpm/jose@6.1.2/node_modules/jose/dist/webapi/lib/is_disjoint.js","../../node_modules/.pnpm/jose@6.1.2/node_modules/jose/dist/webapi/lib/is_key_like.js","../../node_modules/.pnpm/jose@6.1.2/node_modules/jose/dist/webapi/lib/is_object.js","../../node_modules/.pnpm/jose@6.1.2/node_modules/jose/dist/webapi/lib/is_jwk.js","../../node_modules/.pnpm/jose@6.1.2/node_modules/jose/dist/webapi/lib/check_key_type.js","../../node_modules/.pnpm/jose@6.1.2/node_modules/jose/dist/webapi/lib/validate_crit.js","../../node_modules/.pnpm/jose@6.1.2/node_modules/jose/dist/webapi/lib/jwk_to_key.js","../../node_modules/.pnpm/jose@6.1.2/node_modules/jose/dist/webapi/lib/normalize_key.js","../../node_modules/.pnpm/jose@6.1.2/node_modules/jose/dist/webapi/jws/flattened/sign.js","../../node_modules/.pnpm/jose@6.1.2/node_modules/jose/dist/webapi/jws/compact/sign.js","../../node_modules/.pnpm/jose@6.1.2/node_modules/jose/dist/webapi/lib/jwt_claims_set.js","../../node_modules/.pnpm/jose@6.1.2/node_modules/jose/dist/webapi/jwt/sign.js","../../package/esm/index.js","../esm/main.mjs"],"sourcesContent":[null,"// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = new URL('.', import.meta.url).pathname.slice(import.meta.url.match(/^file:\\/\\/\\/\\w:/) ? 1 : 0, -1) + \"/\";","export function encodeBase64(input) {\n    if (Uint8Array.prototype.toBase64) {\n        return input.toBase64();\n    }\n    const CHUNK_SIZE = 0x8000;\n    const arr = [];\n    for (let i = 0; i < input.length; i += CHUNK_SIZE) {\n        arr.push(String.fromCharCode.apply(null, input.subarray(i, i + CHUNK_SIZE)));\n    }\n    return btoa(arr.join(''));\n}\nexport function decodeBase64(encoded) {\n    if (Uint8Array.fromBase64) {\n        return Uint8Array.fromBase64(encoded);\n    }\n    const binary = atob(encoded);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n}\n","export class JOSEError extends Error {\n    static code = 'ERR_JOSE_GENERIC';\n    code = 'ERR_JOSE_GENERIC';\n    constructor(message, options) {\n        super(message, options);\n        this.name = this.constructor.name;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nexport class JWTClaimValidationFailed extends JOSEError {\n    static code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n    code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n    claim;\n    reason;\n    payload;\n    constructor(message, payload, claim = 'unspecified', reason = 'unspecified') {\n        super(message, { cause: { claim, reason, payload } });\n        this.claim = claim;\n        this.reason = reason;\n        this.payload = payload;\n    }\n}\nexport class JWTExpired extends JOSEError {\n    static code = 'ERR_JWT_EXPIRED';\n    code = 'ERR_JWT_EXPIRED';\n    claim;\n    reason;\n    payload;\n    constructor(message, payload, claim = 'unspecified', reason = 'unspecified') {\n        super(message, { cause: { claim, reason, payload } });\n        this.claim = claim;\n        this.reason = reason;\n        this.payload = payload;\n    }\n}\nexport class JOSEAlgNotAllowed extends JOSEError {\n    static code = 'ERR_JOSE_ALG_NOT_ALLOWED';\n    code = 'ERR_JOSE_ALG_NOT_ALLOWED';\n}\nexport class JOSENotSupported extends JOSEError {\n    static code = 'ERR_JOSE_NOT_SUPPORTED';\n    code = 'ERR_JOSE_NOT_SUPPORTED';\n}\nexport class JWEDecryptionFailed extends JOSEError {\n    static code = 'ERR_JWE_DECRYPTION_FAILED';\n    code = 'ERR_JWE_DECRYPTION_FAILED';\n    constructor(message = 'decryption operation failed', options) {\n        super(message, options);\n    }\n}\nexport class JWEInvalid extends JOSEError {\n    static code = 'ERR_JWE_INVALID';\n    code = 'ERR_JWE_INVALID';\n}\nexport class JWSInvalid extends JOSEError {\n    static code = 'ERR_JWS_INVALID';\n    code = 'ERR_JWS_INVALID';\n}\nexport class JWTInvalid extends JOSEError {\n    static code = 'ERR_JWT_INVALID';\n    code = 'ERR_JWT_INVALID';\n}\nexport class JWKInvalid extends JOSEError {\n    static code = 'ERR_JWK_INVALID';\n    code = 'ERR_JWK_INVALID';\n}\nexport class JWKSInvalid extends JOSEError {\n    static code = 'ERR_JWKS_INVALID';\n    code = 'ERR_JWKS_INVALID';\n}\nexport class JWKSNoMatchingKey extends JOSEError {\n    static code = 'ERR_JWKS_NO_MATCHING_KEY';\n    code = 'ERR_JWKS_NO_MATCHING_KEY';\n    constructor(message = 'no applicable key found in the JSON Web Key Set', options) {\n        super(message, options);\n    }\n}\nexport class JWKSMultipleMatchingKeys extends JOSEError {\n    [Symbol.asyncIterator];\n    static code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n    code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n    constructor(message = 'multiple matching keys found in the JSON Web Key Set', options) {\n        super(message, options);\n    }\n}\nexport class JWKSTimeout extends JOSEError {\n    static code = 'ERR_JWKS_TIMEOUT';\n    code = 'ERR_JWKS_TIMEOUT';\n    constructor(message = 'request timed out', options) {\n        super(message, options);\n    }\n}\nexport class JWSSignatureVerificationFailed extends JOSEError {\n    static code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n    code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n    constructor(message = 'signature verification failed', options) {\n        super(message, options);\n    }\n}\n","import { invalidKeyInput } from './invalid_key_input.js';\nimport { encodeBase64, decodeBase64 } from '../lib/base64.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport { isCryptoKey, isKeyObject } from './is_key_like.js';\nconst formatPEM = (b64, descriptor) => {\n    const newlined = (b64.match(/.{1,64}/g) || []).join('\\n');\n    return `-----BEGIN ${descriptor}-----\\n${newlined}\\n-----END ${descriptor}-----`;\n};\nconst genericExport = async (keyType, keyFormat, key) => {\n    if (isKeyObject(key)) {\n        if (key.type !== keyType) {\n            throw new TypeError(`key is not a ${keyType} key`);\n        }\n        return key.export({ format: 'pem', type: keyFormat });\n    }\n    if (!isCryptoKey(key)) {\n        throw new TypeError(invalidKeyInput(key, 'CryptoKey', 'KeyObject'));\n    }\n    if (!key.extractable) {\n        throw new TypeError('CryptoKey is not extractable');\n    }\n    if (key.type !== keyType) {\n        throw new TypeError(`key is not a ${keyType} key`);\n    }\n    return formatPEM(encodeBase64(new Uint8Array(await crypto.subtle.exportKey(keyFormat, key))), `${keyType.toUpperCase()} KEY`);\n};\nexport const toSPKI = (key) => genericExport('public', 'spki', key);\nexport const toPKCS8 = (key) => genericExport('private', 'pkcs8', key);\nconst bytesEqual = (a, b) => {\n    if (a.byteLength !== b.length)\n        return false;\n    for (let i = 0; i < a.byteLength; i++) {\n        if (a[i] !== b[i])\n            return false;\n    }\n    return true;\n};\nconst createASN1State = (data) => ({ data, pos: 0 });\nconst parseLength = (state) => {\n    const first = state.data[state.pos++];\n    if (first & 0x80) {\n        const lengthOfLen = first & 0x7f;\n        let length = 0;\n        for (let i = 0; i < lengthOfLen; i++) {\n            length = (length << 8) | state.data[state.pos++];\n        }\n        return length;\n    }\n    return first;\n};\nconst skipElement = (state, count = 1) => {\n    if (count <= 0)\n        return;\n    state.pos++;\n    const length = parseLength(state);\n    state.pos += length;\n    if (count > 1) {\n        skipElement(state, count - 1);\n    }\n};\nconst expectTag = (state, expectedTag, errorMessage) => {\n    if (state.data[state.pos++] !== expectedTag) {\n        throw new Error(errorMessage);\n    }\n};\nconst getSubarray = (state, length) => {\n    const result = state.data.subarray(state.pos, state.pos + length);\n    state.pos += length;\n    return result;\n};\nconst parseAlgorithmOID = (state) => {\n    expectTag(state, 0x06, 'Expected algorithm OID');\n    const oidLen = parseLength(state);\n    return getSubarray(state, oidLen);\n};\nfunction parsePKCS8Header(state) {\n    expectTag(state, 0x30, 'Invalid PKCS#8 structure');\n    parseLength(state);\n    expectTag(state, 0x02, 'Expected version field');\n    const verLen = parseLength(state);\n    state.pos += verLen;\n    expectTag(state, 0x30, 'Expected algorithm identifier');\n    const algIdLen = parseLength(state);\n    const algIdStart = state.pos;\n    return { algIdStart, algIdLength: algIdLen };\n}\nfunction parseSPKIHeader(state) {\n    expectTag(state, 0x30, 'Invalid SPKI structure');\n    parseLength(state);\n    expectTag(state, 0x30, 'Expected algorithm identifier');\n    const algIdLen = parseLength(state);\n    const algIdStart = state.pos;\n    return { algIdStart, algIdLength: algIdLen };\n}\nconst parseECAlgorithmIdentifier = (state) => {\n    const algOid = parseAlgorithmOID(state);\n    if (bytesEqual(algOid, [0x2b, 0x65, 0x6e])) {\n        return 'X25519';\n    }\n    if (!bytesEqual(algOid, [0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01])) {\n        throw new Error('Unsupported key algorithm');\n    }\n    expectTag(state, 0x06, 'Expected curve OID');\n    const curveOidLen = parseLength(state);\n    const curveOid = getSubarray(state, curveOidLen);\n    for (const { name, oid } of [\n        { name: 'P-256', oid: [0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07] },\n        { name: 'P-384', oid: [0x2b, 0x81, 0x04, 0x00, 0x22] },\n        { name: 'P-521', oid: [0x2b, 0x81, 0x04, 0x00, 0x23] },\n    ]) {\n        if (bytesEqual(curveOid, oid)) {\n            return name;\n        }\n    }\n    throw new Error('Unsupported named curve');\n};\nconst genericImport = async (keyFormat, keyData, alg, options) => {\n    let algorithm;\n    let keyUsages;\n    const isPublic = keyFormat === 'spki';\n    const getSigUsages = () => (isPublic ? ['verify'] : ['sign']);\n    const getEncUsages = () => isPublic ? ['encrypt', 'wrapKey'] : ['decrypt', 'unwrapKey'];\n    switch (alg) {\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n            algorithm = { name: 'RSA-PSS', hash: `SHA-${alg.slice(-3)}` };\n            keyUsages = getSigUsages();\n            break;\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            algorithm = { name: 'RSASSA-PKCS1-v1_5', hash: `SHA-${alg.slice(-3)}` };\n            keyUsages = getSigUsages();\n            break;\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512':\n            algorithm = {\n                name: 'RSA-OAEP',\n                hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`,\n            };\n            keyUsages = getEncUsages();\n            break;\n        case 'ES256':\n        case 'ES384':\n        case 'ES512': {\n            const curveMap = { ES256: 'P-256', ES384: 'P-384', ES512: 'P-521' };\n            algorithm = { name: 'ECDSA', namedCurve: curveMap[alg] };\n            keyUsages = getSigUsages();\n            break;\n        }\n        case 'ECDH-ES':\n        case 'ECDH-ES+A128KW':\n        case 'ECDH-ES+A192KW':\n        case 'ECDH-ES+A256KW': {\n            try {\n                const namedCurve = options.getNamedCurve(keyData);\n                algorithm = namedCurve === 'X25519' ? { name: 'X25519' } : { name: 'ECDH', namedCurve };\n            }\n            catch (cause) {\n                throw new JOSENotSupported('Invalid or unsupported key format');\n            }\n            keyUsages = isPublic ? [] : ['deriveBits'];\n            break;\n        }\n        case 'Ed25519':\n        case 'EdDSA':\n            algorithm = { name: 'Ed25519' };\n            keyUsages = getSigUsages();\n            break;\n        case 'ML-DSA-44':\n        case 'ML-DSA-65':\n        case 'ML-DSA-87':\n            algorithm = { name: alg };\n            keyUsages = getSigUsages();\n            break;\n        default:\n            throw new JOSENotSupported('Invalid or unsupported \"alg\" (Algorithm) value');\n    }\n    return crypto.subtle.importKey(keyFormat, keyData, algorithm, options?.extractable ?? (isPublic ? true : false), keyUsages);\n};\nconst processPEMData = (pem, pattern) => {\n    return decodeBase64(pem.replace(pattern, ''));\n};\nexport const fromPKCS8 = (pem, alg, options) => {\n    const keyData = processPEMData(pem, /(?:-----(?:BEGIN|END) PRIVATE KEY-----|\\s)/g);\n    let opts = options;\n    if (alg?.startsWith?.('ECDH-ES')) {\n        opts ||= {};\n        opts.getNamedCurve = (keyData) => {\n            const state = createASN1State(keyData);\n            parsePKCS8Header(state);\n            return parseECAlgorithmIdentifier(state);\n        };\n    }\n    return genericImport('pkcs8', keyData, alg, opts);\n};\nexport const fromSPKI = (pem, alg, options) => {\n    const keyData = processPEMData(pem, /(?:-----(?:BEGIN|END) PUBLIC KEY-----|\\s)/g);\n    let opts = options;\n    if (alg?.startsWith?.('ECDH-ES')) {\n        opts ||= {};\n        opts.getNamedCurve = (keyData) => {\n            const state = createASN1State(keyData);\n            parseSPKIHeader(state);\n            return parseECAlgorithmIdentifier(state);\n        };\n    }\n    return genericImport('spki', keyData, alg, opts);\n};\nfunction spkiFromX509(buf) {\n    const state = createASN1State(buf);\n    expectTag(state, 0x30, 'Invalid certificate structure');\n    parseLength(state);\n    expectTag(state, 0x30, 'Invalid tbsCertificate structure');\n    parseLength(state);\n    if (buf[state.pos] === 0xa0) {\n        skipElement(state, 6);\n    }\n    else {\n        skipElement(state, 5);\n    }\n    const spkiStart = state.pos;\n    expectTag(state, 0x30, 'Invalid SPKI structure');\n    const spkiContentLen = parseLength(state);\n    return buf.subarray(spkiStart, spkiStart + spkiContentLen + (state.pos - spkiStart));\n}\nfunction extractX509SPKI(x509) {\n    const derBytes = processPEMData(x509, /(?:-----(?:BEGIN|END) CERTIFICATE-----|\\s)/g);\n    return spkiFromX509(derBytes);\n}\nexport const fromX509 = (pem, alg, options) => {\n    let spki;\n    try {\n        spki = extractX509SPKI(pem);\n    }\n    catch (cause) {\n        throw new TypeError('Failed to parse the X.509 certificate', { cause });\n    }\n    return fromSPKI(formatPEM(encodeBase64(spki), 'PUBLIC KEY'), alg, options);\n};\n","import { decode as decodeBase64URL } from '../util/base64url.js';\nimport { fromSPKI, fromPKCS8, fromX509 } from '../lib/asn1.js';\nimport { jwkToKey } from '../lib/jwk_to_key.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport { isObject } from '../lib/is_object.js';\nexport async function importSPKI(spki, alg, options) {\n    if (typeof spki !== 'string' || spki.indexOf('-----BEGIN PUBLIC KEY-----') !== 0) {\n        throw new TypeError('\"spki\" must be SPKI formatted string');\n    }\n    return fromSPKI(spki, alg, options);\n}\nexport async function importX509(x509, alg, options) {\n    if (typeof x509 !== 'string' || x509.indexOf('-----BEGIN CERTIFICATE-----') !== 0) {\n        throw new TypeError('\"x509\" must be X.509 formatted string');\n    }\n    return fromX509(x509, alg, options);\n}\nexport async function importPKCS8(pkcs8, alg, options) {\n    if (typeof pkcs8 !== 'string' || pkcs8.indexOf('-----BEGIN PRIVATE KEY-----') !== 0) {\n        throw new TypeError('\"pkcs8\" must be PKCS#8 formatted string');\n    }\n    return fromPKCS8(pkcs8, alg, options);\n}\nexport async function importJWK(jwk, alg, options) {\n    if (!isObject(jwk)) {\n        throw new TypeError('JWK must be an object');\n    }\n    let ext;\n    alg ??= jwk.alg;\n    ext ??= options?.extractable ?? jwk.ext;\n    switch (jwk.kty) {\n        case 'oct':\n            if (typeof jwk.k !== 'string' || !jwk.k) {\n                throw new TypeError('missing \"k\" (Key Value) Parameter value');\n            }\n            return decodeBase64URL(jwk.k);\n        case 'RSA':\n            if ('oth' in jwk && jwk.oth !== undefined) {\n                throw new JOSENotSupported('RSA JWK \"oth\" (Other Primes Info) Parameter value is not supported');\n            }\n            return jwkToKey({ ...jwk, alg, ext });\n        case 'AKP': {\n            if (typeof jwk.alg !== 'string' || !jwk.alg) {\n                throw new TypeError('missing \"alg\" (Algorithm) Parameter value');\n            }\n            if (alg !== undefined && alg !== jwk.alg) {\n                throw new TypeError('JWK alg and alg option value mismatch');\n            }\n            return jwkToKey({ ...jwk, ext });\n        }\n        case 'EC':\n        case 'OKP':\n            return jwkToKey({ ...jwk, alg, ext });\n        default:\n            throw new JOSENotSupported('Unsupported \"kty\" (Key Type) Parameter value');\n    }\n}\n","export const encoder = new TextEncoder();\nexport const decoder = new TextDecoder();\nconst MAX_INT32 = 2 ** 32;\nexport function concat(...buffers) {\n    const size = buffers.reduce((acc, { length }) => acc + length, 0);\n    const buf = new Uint8Array(size);\n    let i = 0;\n    for (const buffer of buffers) {\n        buf.set(buffer, i);\n        i += buffer.length;\n    }\n    return buf;\n}\nfunction writeUInt32BE(buf, value, offset) {\n    if (value < 0 || value >= MAX_INT32) {\n        throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);\n    }\n    buf.set([value >>> 24, value >>> 16, value >>> 8, value & 0xff], offset);\n}\nexport function uint64be(value) {\n    const high = Math.floor(value / MAX_INT32);\n    const low = value % MAX_INT32;\n    const buf = new Uint8Array(8);\n    writeUInt32BE(buf, high, 0);\n    writeUInt32BE(buf, low, 4);\n    return buf;\n}\nexport function uint32be(value) {\n    const buf = new Uint8Array(4);\n    writeUInt32BE(buf, value);\n    return buf;\n}\nexport function encode(string) {\n    const bytes = new Uint8Array(string.length);\n    for (let i = 0; i < string.length; i++) {\n        const code = string.charCodeAt(i);\n        if (code > 127) {\n            throw new TypeError('non-ASCII string encountered in encode()');\n        }\n        bytes[i] = code;\n    }\n    return bytes;\n}\n","import { encoder, decoder } from '../lib/buffer_utils.js';\nimport { encodeBase64, decodeBase64 } from '../lib/base64.js';\nexport function decode(input) {\n    if (Uint8Array.fromBase64) {\n        return Uint8Array.fromBase64(typeof input === 'string' ? input : decoder.decode(input), {\n            alphabet: 'base64url',\n        });\n    }\n    let encoded = input;\n    if (encoded instanceof Uint8Array) {\n        encoded = decoder.decode(encoded);\n    }\n    encoded = encoded.replace(/-/g, '+').replace(/_/g, '/');\n    try {\n        return decodeBase64(encoded);\n    }\n    catch {\n        throw new TypeError('The input to be decoded is not correctly encoded.');\n    }\n}\nexport function encode(input) {\n    let unencoded = input;\n    if (typeof unencoded === 'string') {\n        unencoded = encoder.encode(unencoded);\n    }\n    if (Uint8Array.prototype.toBase64) {\n        return unencoded.toBase64({ alphabet: 'base64url', omitPadding: true });\n    }\n    return encodeBase64(unencoded).replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n}\n","import { JOSENotSupported } from '../util/errors.js';\nexport function subtleAlgorithm(alg, algorithm) {\n    const hash = `SHA-${alg.slice(-3)}`;\n    switch (alg) {\n        case 'HS256':\n        case 'HS384':\n        case 'HS512':\n            return { hash, name: 'HMAC' };\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n            return { hash, name: 'RSA-PSS', saltLength: parseInt(alg.slice(-3), 10) >> 3 };\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            return { hash, name: 'RSASSA-PKCS1-v1_5' };\n        case 'ES256':\n        case 'ES384':\n        case 'ES512':\n            return { hash, name: 'ECDSA', namedCurve: algorithm.namedCurve };\n        case 'Ed25519':\n        case 'EdDSA':\n            return { name: 'Ed25519' };\n        case 'ML-DSA-44':\n        case 'ML-DSA-65':\n        case 'ML-DSA-87':\n            return { name: alg };\n        default:\n            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);\n    }\n}\n","export function checkKeyLength(alg, key) {\n    if (alg.startsWith('RS') || alg.startsWith('PS')) {\n        const { modulusLength } = key.algorithm;\n        if (typeof modulusLength !== 'number' || modulusLength < 2048) {\n            throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);\n        }\n    }\n}\n","const unusable = (name, prop = 'algorithm.name') => new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);\nconst isAlgorithm = (algorithm, name) => algorithm.name === name;\nfunction getHashLength(hash) {\n    return parseInt(hash.name.slice(4), 10);\n}\nfunction getNamedCurve(alg) {\n    switch (alg) {\n        case 'ES256':\n            return 'P-256';\n        case 'ES384':\n            return 'P-384';\n        case 'ES512':\n            return 'P-521';\n        default:\n            throw new Error('unreachable');\n    }\n}\nfunction checkUsage(key, usage) {\n    if (usage && !key.usages.includes(usage)) {\n        throw new TypeError(`CryptoKey does not support this operation, its usages must include ${usage}.`);\n    }\n}\nexport function checkSigCryptoKey(key, alg, usage) {\n    switch (alg) {\n        case 'HS256':\n        case 'HS384':\n        case 'HS512': {\n            if (!isAlgorithm(key.algorithm, 'HMAC'))\n                throw unusable('HMAC');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'RS256':\n        case 'RS384':\n        case 'RS512': {\n            if (!isAlgorithm(key.algorithm, 'RSASSA-PKCS1-v1_5'))\n                throw unusable('RSASSA-PKCS1-v1_5');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'PS256':\n        case 'PS384':\n        case 'PS512': {\n            if (!isAlgorithm(key.algorithm, 'RSA-PSS'))\n                throw unusable('RSA-PSS');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'Ed25519':\n        case 'EdDSA': {\n            if (!isAlgorithm(key.algorithm, 'Ed25519'))\n                throw unusable('Ed25519');\n            break;\n        }\n        case 'ML-DSA-44':\n        case 'ML-DSA-65':\n        case 'ML-DSA-87': {\n            if (!isAlgorithm(key.algorithm, alg))\n                throw unusable(alg);\n            break;\n        }\n        case 'ES256':\n        case 'ES384':\n        case 'ES512': {\n            if (!isAlgorithm(key.algorithm, 'ECDSA'))\n                throw unusable('ECDSA');\n            const expected = getNamedCurve(alg);\n            const actual = key.algorithm.namedCurve;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.namedCurve');\n            break;\n        }\n        default:\n            throw new TypeError('CryptoKey does not support this operation');\n    }\n    checkUsage(key, usage);\n}\nexport function checkEncCryptoKey(key, alg, usage) {\n    switch (alg) {\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM': {\n            if (!isAlgorithm(key.algorithm, 'AES-GCM'))\n                throw unusable('AES-GCM');\n            const expected = parseInt(alg.slice(1, 4), 10);\n            const actual = key.algorithm.length;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.length');\n            break;\n        }\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW': {\n            if (!isAlgorithm(key.algorithm, 'AES-KW'))\n                throw unusable('AES-KW');\n            const expected = parseInt(alg.slice(1, 4), 10);\n            const actual = key.algorithm.length;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.length');\n            break;\n        }\n        case 'ECDH': {\n            switch (key.algorithm.name) {\n                case 'ECDH':\n                case 'X25519':\n                    break;\n                default:\n                    throw unusable('ECDH or X25519');\n            }\n            break;\n        }\n        case 'PBES2-HS256+A128KW':\n        case 'PBES2-HS384+A192KW':\n        case 'PBES2-HS512+A256KW':\n            if (!isAlgorithm(key.algorithm, 'PBKDF2'))\n                throw unusable('PBKDF2');\n            break;\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512': {\n            if (!isAlgorithm(key.algorithm, 'RSA-OAEP'))\n                throw unusable('RSA-OAEP');\n            const expected = parseInt(alg.slice(9), 10) || 1;\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        default:\n            throw new TypeError('CryptoKey does not support this operation');\n    }\n    checkUsage(key, usage);\n}\n","function message(msg, actual, ...types) {\n    types = types.filter(Boolean);\n    if (types.length > 2) {\n        const last = types.pop();\n        msg += `one of type ${types.join(', ')}, or ${last}.`;\n    }\n    else if (types.length === 2) {\n        msg += `one of type ${types[0]} or ${types[1]}.`;\n    }\n    else {\n        msg += `of type ${types[0]}.`;\n    }\n    if (actual == null) {\n        msg += ` Received ${actual}`;\n    }\n    else if (typeof actual === 'function' && actual.name) {\n        msg += ` Received function ${actual.name}`;\n    }\n    else if (typeof actual === 'object' && actual != null) {\n        if (actual.constructor?.name) {\n            msg += ` Received an instance of ${actual.constructor.name}`;\n        }\n    }\n    return msg;\n}\nexport const invalidKeyInput = (actual, ...types) => message('Key must be ', actual, ...types);\nexport const withAlg = (alg, actual, ...types) => message(`Key for the ${alg} algorithm must be `, actual, ...types);\n","import { checkSigCryptoKey } from './crypto_key.js';\nimport { invalidKeyInput } from './invalid_key_input.js';\nexport async function getSigKey(alg, key, usage) {\n    if (key instanceof Uint8Array) {\n        if (!alg.startsWith('HS')) {\n            throw new TypeError(invalidKeyInput(key, 'CryptoKey', 'KeyObject', 'JSON Web Key'));\n        }\n        return crypto.subtle.importKey('raw', key, { hash: `SHA-${alg.slice(-3)}`, name: 'HMAC' }, false, [usage]);\n    }\n    checkSigCryptoKey(key, alg, usage);\n    return key;\n}\n","import { subtleAlgorithm } from './subtle_dsa.js';\nimport { checkKeyLength } from './check_key_length.js';\nimport { getSigKey } from './get_sign_verify_key.js';\nexport async function sign(alg, key, data) {\n    const cryptoKey = await getSigKey(alg, key, 'sign');\n    checkKeyLength(alg, cryptoKey);\n    const signature = await crypto.subtle.sign(subtleAlgorithm(alg, cryptoKey.algorithm), cryptoKey, data);\n    return new Uint8Array(signature);\n}\n","export function isDisjoint(...headers) {\n    const sources = headers.filter(Boolean);\n    if (sources.length === 0 || sources.length === 1) {\n        return true;\n    }\n    let acc;\n    for (const header of sources) {\n        const parameters = Object.keys(header);\n        if (!acc || acc.size === 0) {\n            acc = new Set(parameters);\n            continue;\n        }\n        for (const parameter of parameters) {\n            if (acc.has(parameter)) {\n                return false;\n            }\n            acc.add(parameter);\n        }\n    }\n    return true;\n}\n","export function assertCryptoKey(key) {\n    if (!isCryptoKey(key)) {\n        throw new Error('CryptoKey instance expected');\n    }\n}\nexport const isCryptoKey = (key) => {\n    if (key?.[Symbol.toStringTag] === 'CryptoKey')\n        return true;\n    try {\n        return key instanceof CryptoKey;\n    }\n    catch {\n        return false;\n    }\n};\nexport const isKeyObject = (key) => key?.[Symbol.toStringTag] === 'KeyObject';\nexport const isKeyLike = (key) => isCryptoKey(key) || isKeyObject(key);\n","const isObjectLike = (value) => typeof value === 'object' && value !== null;\nexport function isObject(input) {\n    if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') {\n        return false;\n    }\n    if (Object.getPrototypeOf(input) === null) {\n        return true;\n    }\n    let proto = input;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(input) === proto;\n}\n","import { isObject } from './is_object.js';\nexport const isJWK = (key) => isObject(key) && typeof key.kty === 'string';\nexport const isPrivateJWK = (key) => key.kty !== 'oct' &&\n    ((key.kty === 'AKP' && typeof key.priv === 'string') || typeof key.d === 'string');\nexport const isPublicJWK = (key) => key.kty !== 'oct' && key.d === undefined && key.priv === undefined;\nexport const isSecretJWK = (key) => key.kty === 'oct' && typeof key.k === 'string';\n","import { withAlg as invalidKeyInput } from './invalid_key_input.js';\nimport { isKeyLike } from './is_key_like.js';\nimport * as jwk from './is_jwk.js';\nconst tag = (key) => key?.[Symbol.toStringTag];\nconst jwkMatchesOp = (alg, key, usage) => {\n    if (key.use !== undefined) {\n        let expected;\n        switch (usage) {\n            case 'sign':\n            case 'verify':\n                expected = 'sig';\n                break;\n            case 'encrypt':\n            case 'decrypt':\n                expected = 'enc';\n                break;\n        }\n        if (key.use !== expected) {\n            throw new TypeError(`Invalid key for this operation, its \"use\" must be \"${expected}\" when present`);\n        }\n    }\n    if (key.alg !== undefined && key.alg !== alg) {\n        throw new TypeError(`Invalid key for this operation, its \"alg\" must be \"${alg}\" when present`);\n    }\n    if (Array.isArray(key.key_ops)) {\n        let expectedKeyOp;\n        switch (true) {\n            case usage === 'sign' || usage === 'verify':\n            case alg === 'dir':\n            case alg.includes('CBC-HS'):\n                expectedKeyOp = usage;\n                break;\n            case alg.startsWith('PBES2'):\n                expectedKeyOp = 'deriveBits';\n                break;\n            case /^A\\d{3}(?:GCM)?(?:KW)?$/.test(alg):\n                if (!alg.includes('GCM') && alg.endsWith('KW')) {\n                    expectedKeyOp = usage === 'encrypt' ? 'wrapKey' : 'unwrapKey';\n                }\n                else {\n                    expectedKeyOp = usage;\n                }\n                break;\n            case usage === 'encrypt' && alg.startsWith('RSA'):\n                expectedKeyOp = 'wrapKey';\n                break;\n            case usage === 'decrypt':\n                expectedKeyOp = alg.startsWith('RSA') ? 'unwrapKey' : 'deriveBits';\n                break;\n        }\n        if (expectedKeyOp && key.key_ops?.includes?.(expectedKeyOp) === false) {\n            throw new TypeError(`Invalid key for this operation, its \"key_ops\" must include \"${expectedKeyOp}\" when present`);\n        }\n    }\n    return true;\n};\nconst symmetricTypeCheck = (alg, key, usage) => {\n    if (key instanceof Uint8Array)\n        return;\n    if (jwk.isJWK(key)) {\n        if (jwk.isSecretJWK(key) && jwkMatchesOp(alg, key, usage))\n            return;\n        throw new TypeError(`JSON Web Key for symmetric algorithms must have JWK \"kty\" (Key Type) equal to \"oct\" and the JWK \"k\" (Key Value) present`);\n    }\n    if (!isKeyLike(key)) {\n        throw new TypeError(invalidKeyInput(alg, key, 'CryptoKey', 'KeyObject', 'JSON Web Key', 'Uint8Array'));\n    }\n    if (key.type !== 'secret') {\n        throw new TypeError(`${tag(key)} instances for symmetric algorithms must be of type \"secret\"`);\n    }\n};\nconst asymmetricTypeCheck = (alg, key, usage) => {\n    if (jwk.isJWK(key)) {\n        switch (usage) {\n            case 'decrypt':\n            case 'sign':\n                if (jwk.isPrivateJWK(key) && jwkMatchesOp(alg, key, usage))\n                    return;\n                throw new TypeError(`JSON Web Key for this operation be a private JWK`);\n            case 'encrypt':\n            case 'verify':\n                if (jwk.isPublicJWK(key) && jwkMatchesOp(alg, key, usage))\n                    return;\n                throw new TypeError(`JSON Web Key for this operation be a public JWK`);\n        }\n    }\n    if (!isKeyLike(key)) {\n        throw new TypeError(invalidKeyInput(alg, key, 'CryptoKey', 'KeyObject', 'JSON Web Key'));\n    }\n    if (key.type === 'secret') {\n        throw new TypeError(`${tag(key)} instances for asymmetric algorithms must not be of type \"secret\"`);\n    }\n    if (key.type === 'public') {\n        switch (usage) {\n            case 'sign':\n                throw new TypeError(`${tag(key)} instances for asymmetric algorithm signing must be of type \"private\"`);\n            case 'decrypt':\n                throw new TypeError(`${tag(key)} instances for asymmetric algorithm decryption must be of type \"private\"`);\n        }\n    }\n    if (key.type === 'private') {\n        switch (usage) {\n            case 'verify':\n                throw new TypeError(`${tag(key)} instances for asymmetric algorithm verifying must be of type \"public\"`);\n            case 'encrypt':\n                throw new TypeError(`${tag(key)} instances for asymmetric algorithm encryption must be of type \"public\"`);\n        }\n    }\n};\nexport function checkKeyType(alg, key, usage) {\n    switch (alg.substring(0, 2)) {\n        case 'A1':\n        case 'A2':\n        case 'di':\n        case 'HS':\n        case 'PB':\n            symmetricTypeCheck(alg, key, usage);\n            break;\n        default:\n            asymmetricTypeCheck(alg, key, usage);\n    }\n}\n","import { JOSENotSupported, JWEInvalid, JWSInvalid } from '../util/errors.js';\nexport function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {\n    if (joseHeader.crit !== undefined && protectedHeader?.crit === undefined) {\n        throw new Err('\"crit\" (Critical) Header Parameter MUST be integrity protected');\n    }\n    if (!protectedHeader || protectedHeader.crit === undefined) {\n        return new Set();\n    }\n    if (!Array.isArray(protectedHeader.crit) ||\n        protectedHeader.crit.length === 0 ||\n        protectedHeader.crit.some((input) => typeof input !== 'string' || input.length === 0)) {\n        throw new Err('\"crit\" (Critical) Header Parameter MUST be an array of non-empty strings when present');\n    }\n    let recognized;\n    if (recognizedOption !== undefined) {\n        recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);\n    }\n    else {\n        recognized = recognizedDefault;\n    }\n    for (const parameter of protectedHeader.crit) {\n        if (!recognized.has(parameter)) {\n            throw new JOSENotSupported(`Extension Header Parameter \"${parameter}\" is not recognized`);\n        }\n        if (joseHeader[parameter] === undefined) {\n            throw new Err(`Extension Header Parameter \"${parameter}\" is missing`);\n        }\n        if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {\n            throw new Err(`Extension Header Parameter \"${parameter}\" MUST be integrity protected`);\n        }\n    }\n    return new Set(protectedHeader.crit);\n}\n","import { JOSENotSupported } from '../util/errors.js';\nfunction subtleMapping(jwk) {\n    let algorithm;\n    let keyUsages;\n    switch (jwk.kty) {\n        case 'AKP': {\n            switch (jwk.alg) {\n                case 'ML-DSA-44':\n                case 'ML-DSA-65':\n                case 'ML-DSA-87':\n                    algorithm = { name: jwk.alg };\n                    keyUsages = jwk.priv ? ['sign'] : ['verify'];\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        case 'RSA': {\n            switch (jwk.alg) {\n                case 'PS256':\n                case 'PS384':\n                case 'PS512':\n                    algorithm = { name: 'RSA-PSS', hash: `SHA-${jwk.alg.slice(-3)}` };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'RS256':\n                case 'RS384':\n                case 'RS512':\n                    algorithm = { name: 'RSASSA-PKCS1-v1_5', hash: `SHA-${jwk.alg.slice(-3)}` };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'RSA-OAEP':\n                case 'RSA-OAEP-256':\n                case 'RSA-OAEP-384':\n                case 'RSA-OAEP-512':\n                    algorithm = {\n                        name: 'RSA-OAEP',\n                        hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`,\n                    };\n                    keyUsages = jwk.d ? ['decrypt', 'unwrapKey'] : ['encrypt', 'wrapKey'];\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        case 'EC': {\n            switch (jwk.alg) {\n                case 'ES256':\n                    algorithm = { name: 'ECDSA', namedCurve: 'P-256' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ES384':\n                    algorithm = { name: 'ECDSA', namedCurve: 'P-384' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ES512':\n                    algorithm = { name: 'ECDSA', namedCurve: 'P-521' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ECDH-ES':\n                case 'ECDH-ES+A128KW':\n                case 'ECDH-ES+A192KW':\n                case 'ECDH-ES+A256KW':\n                    algorithm = { name: 'ECDH', namedCurve: jwk.crv };\n                    keyUsages = jwk.d ? ['deriveBits'] : [];\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        case 'OKP': {\n            switch (jwk.alg) {\n                case 'Ed25519':\n                case 'EdDSA':\n                    algorithm = { name: 'Ed25519' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ECDH-ES':\n                case 'ECDH-ES+A128KW':\n                case 'ECDH-ES+A192KW':\n                case 'ECDH-ES+A256KW':\n                    algorithm = { name: jwk.crv };\n                    keyUsages = jwk.d ? ['deriveBits'] : [];\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        default:\n            throw new JOSENotSupported('Invalid or unsupported JWK \"kty\" (Key Type) Parameter value');\n    }\n    return { algorithm, keyUsages };\n}\nexport async function jwkToKey(jwk) {\n    if (!jwk.alg) {\n        throw new TypeError('\"alg\" argument is required when \"jwk.alg\" is not present');\n    }\n    const { algorithm, keyUsages } = subtleMapping(jwk);\n    const keyData = { ...jwk };\n    if (keyData.kty !== 'AKP') {\n        delete keyData.alg;\n    }\n    delete keyData.use;\n    return crypto.subtle.importKey('jwk', keyData, algorithm, jwk.ext ?? (jwk.d || jwk.priv ? false : true), jwk.key_ops ?? keyUsages);\n}\n","import { isJWK } from './is_jwk.js';\nimport { decode } from '../util/base64url.js';\nimport { jwkToKey } from './jwk_to_key.js';\nimport { isCryptoKey, isKeyObject } from './is_key_like.js';\nlet cache;\nconst handleJWK = async (key, jwk, alg, freeze = false) => {\n    cache ||= new WeakMap();\n    let cached = cache.get(key);\n    if (cached?.[alg]) {\n        return cached[alg];\n    }\n    const cryptoKey = await jwkToKey({ ...jwk, alg });\n    if (freeze)\n        Object.freeze(key);\n    if (!cached) {\n        cache.set(key, { [alg]: cryptoKey });\n    }\n    else {\n        cached[alg] = cryptoKey;\n    }\n    return cryptoKey;\n};\nconst handleKeyObject = (keyObject, alg) => {\n    cache ||= new WeakMap();\n    let cached = cache.get(keyObject);\n    if (cached?.[alg]) {\n        return cached[alg];\n    }\n    const isPublic = keyObject.type === 'public';\n    const extractable = isPublic ? true : false;\n    let cryptoKey;\n    if (keyObject.asymmetricKeyType === 'x25519') {\n        switch (alg) {\n            case 'ECDH-ES':\n            case 'ECDH-ES+A128KW':\n            case 'ECDH-ES+A192KW':\n            case 'ECDH-ES+A256KW':\n                break;\n            default:\n                throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n        }\n        cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, isPublic ? [] : ['deriveBits']);\n    }\n    if (keyObject.asymmetricKeyType === 'ed25519') {\n        if (alg !== 'EdDSA' && alg !== 'Ed25519') {\n            throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n        }\n        cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, [\n            isPublic ? 'verify' : 'sign',\n        ]);\n    }\n    switch (keyObject.asymmetricKeyType) {\n        case 'ml-dsa-44':\n        case 'ml-dsa-65':\n        case 'ml-dsa-87': {\n            if (alg !== keyObject.asymmetricKeyType.toUpperCase()) {\n                throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n            }\n            cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, [\n                isPublic ? 'verify' : 'sign',\n            ]);\n        }\n    }\n    if (keyObject.asymmetricKeyType === 'rsa') {\n        let hash;\n        switch (alg) {\n            case 'RSA-OAEP':\n                hash = 'SHA-1';\n                break;\n            case 'RS256':\n            case 'PS256':\n            case 'RSA-OAEP-256':\n                hash = 'SHA-256';\n                break;\n            case 'RS384':\n            case 'PS384':\n            case 'RSA-OAEP-384':\n                hash = 'SHA-384';\n                break;\n            case 'RS512':\n            case 'PS512':\n            case 'RSA-OAEP-512':\n                hash = 'SHA-512';\n                break;\n            default:\n                throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n        }\n        if (alg.startsWith('RSA-OAEP')) {\n            return keyObject.toCryptoKey({\n                name: 'RSA-OAEP',\n                hash,\n            }, extractable, isPublic ? ['encrypt'] : ['decrypt']);\n        }\n        cryptoKey = keyObject.toCryptoKey({\n            name: alg.startsWith('PS') ? 'RSA-PSS' : 'RSASSA-PKCS1-v1_5',\n            hash,\n        }, extractable, [isPublic ? 'verify' : 'sign']);\n    }\n    if (keyObject.asymmetricKeyType === 'ec') {\n        const nist = new Map([\n            ['prime256v1', 'P-256'],\n            ['secp384r1', 'P-384'],\n            ['secp521r1', 'P-521'],\n        ]);\n        const namedCurve = nist.get(keyObject.asymmetricKeyDetails?.namedCurve);\n        if (!namedCurve) {\n            throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n        }\n        if (alg === 'ES256' && namedCurve === 'P-256') {\n            cryptoKey = keyObject.toCryptoKey({\n                name: 'ECDSA',\n                namedCurve,\n            }, extractable, [isPublic ? 'verify' : 'sign']);\n        }\n        if (alg === 'ES384' && namedCurve === 'P-384') {\n            cryptoKey = keyObject.toCryptoKey({\n                name: 'ECDSA',\n                namedCurve,\n            }, extractable, [isPublic ? 'verify' : 'sign']);\n        }\n        if (alg === 'ES512' && namedCurve === 'P-521') {\n            cryptoKey = keyObject.toCryptoKey({\n                name: 'ECDSA',\n                namedCurve,\n            }, extractable, [isPublic ? 'verify' : 'sign']);\n        }\n        if (alg.startsWith('ECDH-ES')) {\n            cryptoKey = keyObject.toCryptoKey({\n                name: 'ECDH',\n                namedCurve,\n            }, extractable, isPublic ? [] : ['deriveBits']);\n        }\n    }\n    if (!cryptoKey) {\n        throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n    }\n    if (!cached) {\n        cache.set(keyObject, { [alg]: cryptoKey });\n    }\n    else {\n        cached[alg] = cryptoKey;\n    }\n    return cryptoKey;\n};\nexport async function normalizeKey(key, alg) {\n    if (key instanceof Uint8Array) {\n        return key;\n    }\n    if (isCryptoKey(key)) {\n        return key;\n    }\n    if (isKeyObject(key)) {\n        if (key.type === 'secret') {\n            return key.export();\n        }\n        if ('toCryptoKey' in key && typeof key.toCryptoKey === 'function') {\n            try {\n                return handleKeyObject(key, alg);\n            }\n            catch (err) {\n                if (err instanceof TypeError) {\n                    throw err;\n                }\n            }\n        }\n        let jwk = key.export({ format: 'jwk' });\n        return handleJWK(key, jwk, alg);\n    }\n    if (isJWK(key)) {\n        if (key.k) {\n            return decode(key.k);\n        }\n        return handleJWK(key, key, alg, true);\n    }\n    throw new Error('unreachable');\n}\n","import { encode as b64u } from '../../util/base64url.js';\nimport { sign } from '../../lib/sign.js';\nimport { isDisjoint } from '../../lib/is_disjoint.js';\nimport { JWSInvalid } from '../../util/errors.js';\nimport { concat, encode } from '../../lib/buffer_utils.js';\nimport { checkKeyType } from '../../lib/check_key_type.js';\nimport { validateCrit } from '../../lib/validate_crit.js';\nimport { normalizeKey } from '../../lib/normalize_key.js';\nexport class FlattenedSign {\n    #payload;\n    #protectedHeader;\n    #unprotectedHeader;\n    constructor(payload) {\n        if (!(payload instanceof Uint8Array)) {\n            throw new TypeError('payload must be an instance of Uint8Array');\n        }\n        this.#payload = payload;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this.#protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this.#protectedHeader = protectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this.#unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this.#unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        if (!this.#protectedHeader && !this.#unprotectedHeader) {\n            throw new JWSInvalid('either setProtectedHeader or setUnprotectedHeader must be called before #sign()');\n        }\n        if (!isDisjoint(this.#protectedHeader, this.#unprotectedHeader)) {\n            throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n        }\n        const joseHeader = {\n            ...this.#protectedHeader,\n            ...this.#unprotectedHeader,\n        };\n        const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options?.crit, this.#protectedHeader, joseHeader);\n        let b64 = true;\n        if (extensions.has('b64')) {\n            b64 = this.#protectedHeader.b64;\n            if (typeof b64 !== 'boolean') {\n                throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n            }\n        }\n        const { alg } = joseHeader;\n        if (typeof alg !== 'string' || !alg) {\n            throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n        }\n        checkKeyType(alg, key, 'sign');\n        let payloadS;\n        let payloadB;\n        if (b64) {\n            payloadS = b64u(this.#payload);\n            payloadB = encode(payloadS);\n        }\n        else {\n            payloadB = this.#payload;\n            payloadS = '';\n        }\n        let protectedHeaderString;\n        let protectedHeaderBytes;\n        if (this.#protectedHeader) {\n            protectedHeaderString = b64u(JSON.stringify(this.#protectedHeader));\n            protectedHeaderBytes = encode(protectedHeaderString);\n        }\n        else {\n            protectedHeaderString = '';\n            protectedHeaderBytes = new Uint8Array();\n        }\n        const data = concat(protectedHeaderBytes, encode('.'), payloadB);\n        const k = await normalizeKey(key, alg);\n        const signature = await sign(alg, k, data);\n        const jws = {\n            signature: b64u(signature),\n            payload: payloadS,\n        };\n        if (this.#unprotectedHeader) {\n            jws.header = this.#unprotectedHeader;\n        }\n        if (this.#protectedHeader) {\n            jws.protected = protectedHeaderString;\n        }\n        return jws;\n    }\n}\n","import { FlattenedSign } from '../flattened/sign.js';\nexport class CompactSign {\n    #flattened;\n    constructor(payload) {\n        this.#flattened = new FlattenedSign(payload);\n    }\n    setProtectedHeader(protectedHeader) {\n        this.#flattened.setProtectedHeader(protectedHeader);\n        return this;\n    }\n    async sign(key, options) {\n        const jws = await this.#flattened.sign(key, options);\n        if (jws.payload === undefined) {\n            throw new TypeError('use the flattened module for creating JWS with b64: false');\n        }\n        return `${jws.protected}.${jws.payload}.${jws.signature}`;\n    }\n}\n","import { JWTClaimValidationFailed, JWTExpired, JWTInvalid } from '../util/errors.js';\nimport { encoder, decoder } from './buffer_utils.js';\nimport { isObject } from './is_object.js';\nconst epoch = (date) => Math.floor(date.getTime() / 1000);\nconst minute = 60;\nconst hour = minute * 60;\nconst day = hour * 24;\nconst week = day * 7;\nconst year = day * 365.25;\nconst REGEX = /^(\\+|\\-)? ?(\\d+|\\d+\\.\\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;\nexport function secs(str) {\n    const matched = REGEX.exec(str);\n    if (!matched || (matched[4] && matched[1])) {\n        throw new TypeError('Invalid time period format');\n    }\n    const value = parseFloat(matched[2]);\n    const unit = matched[3].toLowerCase();\n    let numericDate;\n    switch (unit) {\n        case 'sec':\n        case 'secs':\n        case 'second':\n        case 'seconds':\n        case 's':\n            numericDate = Math.round(value);\n            break;\n        case 'minute':\n        case 'minutes':\n        case 'min':\n        case 'mins':\n        case 'm':\n            numericDate = Math.round(value * minute);\n            break;\n        case 'hour':\n        case 'hours':\n        case 'hr':\n        case 'hrs':\n        case 'h':\n            numericDate = Math.round(value * hour);\n            break;\n        case 'day':\n        case 'days':\n        case 'd':\n            numericDate = Math.round(value * day);\n            break;\n        case 'week':\n        case 'weeks':\n        case 'w':\n            numericDate = Math.round(value * week);\n            break;\n        default:\n            numericDate = Math.round(value * year);\n            break;\n    }\n    if (matched[1] === '-' || matched[4] === 'ago') {\n        return -numericDate;\n    }\n    return numericDate;\n}\nfunction validateInput(label, input) {\n    if (!Number.isFinite(input)) {\n        throw new TypeError(`Invalid ${label} input`);\n    }\n    return input;\n}\nconst normalizeTyp = (value) => {\n    if (value.includes('/')) {\n        return value.toLowerCase();\n    }\n    return `application/${value.toLowerCase()}`;\n};\nconst checkAudiencePresence = (audPayload, audOption) => {\n    if (typeof audPayload === 'string') {\n        return audOption.includes(audPayload);\n    }\n    if (Array.isArray(audPayload)) {\n        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));\n    }\n    return false;\n};\nexport function validateClaimsSet(protectedHeader, encodedPayload, options = {}) {\n    let payload;\n    try {\n        payload = JSON.parse(decoder.decode(encodedPayload));\n    }\n    catch {\n    }\n    if (!isObject(payload)) {\n        throw new JWTInvalid('JWT Claims Set must be a top-level JSON object');\n    }\n    const { typ } = options;\n    if (typ &&\n        (typeof protectedHeader.typ !== 'string' ||\n            normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {\n        throw new JWTClaimValidationFailed('unexpected \"typ\" JWT header value', payload, 'typ', 'check_failed');\n    }\n    const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;\n    const presenceCheck = [...requiredClaims];\n    if (maxTokenAge !== undefined)\n        presenceCheck.push('iat');\n    if (audience !== undefined)\n        presenceCheck.push('aud');\n    if (subject !== undefined)\n        presenceCheck.push('sub');\n    if (issuer !== undefined)\n        presenceCheck.push('iss');\n    for (const claim of new Set(presenceCheck.reverse())) {\n        if (!(claim in payload)) {\n            throw new JWTClaimValidationFailed(`missing required \"${claim}\" claim`, payload, claim, 'missing');\n        }\n    }\n    if (issuer &&\n        !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {\n        throw new JWTClaimValidationFailed('unexpected \"iss\" claim value', payload, 'iss', 'check_failed');\n    }\n    if (subject && payload.sub !== subject) {\n        throw new JWTClaimValidationFailed('unexpected \"sub\" claim value', payload, 'sub', 'check_failed');\n    }\n    if (audience &&\n        !checkAudiencePresence(payload.aud, typeof audience === 'string' ? [audience] : audience)) {\n        throw new JWTClaimValidationFailed('unexpected \"aud\" claim value', payload, 'aud', 'check_failed');\n    }\n    let tolerance;\n    switch (typeof options.clockTolerance) {\n        case 'string':\n            tolerance = secs(options.clockTolerance);\n            break;\n        case 'number':\n            tolerance = options.clockTolerance;\n            break;\n        case 'undefined':\n            tolerance = 0;\n            break;\n        default:\n            throw new TypeError('Invalid clockTolerance option type');\n    }\n    const { currentDate } = options;\n    const now = epoch(currentDate || new Date());\n    if ((payload.iat !== undefined || maxTokenAge) && typeof payload.iat !== 'number') {\n        throw new JWTClaimValidationFailed('\"iat\" claim must be a number', payload, 'iat', 'invalid');\n    }\n    if (payload.nbf !== undefined) {\n        if (typeof payload.nbf !== 'number') {\n            throw new JWTClaimValidationFailed('\"nbf\" claim must be a number', payload, 'nbf', 'invalid');\n        }\n        if (payload.nbf > now + tolerance) {\n            throw new JWTClaimValidationFailed('\"nbf\" claim timestamp check failed', payload, 'nbf', 'check_failed');\n        }\n    }\n    if (payload.exp !== undefined) {\n        if (typeof payload.exp !== 'number') {\n            throw new JWTClaimValidationFailed('\"exp\" claim must be a number', payload, 'exp', 'invalid');\n        }\n        if (payload.exp <= now - tolerance) {\n            throw new JWTExpired('\"exp\" claim timestamp check failed', payload, 'exp', 'check_failed');\n        }\n    }\n    if (maxTokenAge) {\n        const age = now - payload.iat;\n        const max = typeof maxTokenAge === 'number' ? maxTokenAge : secs(maxTokenAge);\n        if (age - tolerance > max) {\n            throw new JWTExpired('\"iat\" claim timestamp check failed (too far in the past)', payload, 'iat', 'check_failed');\n        }\n        if (age < 0 - tolerance) {\n            throw new JWTClaimValidationFailed('\"iat\" claim timestamp check failed (it should be in the past)', payload, 'iat', 'check_failed');\n        }\n    }\n    return payload;\n}\nexport class JWTClaimsBuilder {\n    #payload;\n    constructor(payload) {\n        if (!isObject(payload)) {\n            throw new TypeError('JWT Claims Set MUST be an object');\n        }\n        this.#payload = structuredClone(payload);\n    }\n    data() {\n        return encoder.encode(JSON.stringify(this.#payload));\n    }\n    get iss() {\n        return this.#payload.iss;\n    }\n    set iss(value) {\n        this.#payload.iss = value;\n    }\n    get sub() {\n        return this.#payload.sub;\n    }\n    set sub(value) {\n        this.#payload.sub = value;\n    }\n    get aud() {\n        return this.#payload.aud;\n    }\n    set aud(value) {\n        this.#payload.aud = value;\n    }\n    set jti(value) {\n        this.#payload.jti = value;\n    }\n    set nbf(value) {\n        if (typeof value === 'number') {\n            this.#payload.nbf = validateInput('setNotBefore', value);\n        }\n        else if (value instanceof Date) {\n            this.#payload.nbf = validateInput('setNotBefore', epoch(value));\n        }\n        else {\n            this.#payload.nbf = epoch(new Date()) + secs(value);\n        }\n    }\n    set exp(value) {\n        if (typeof value === 'number') {\n            this.#payload.exp = validateInput('setExpirationTime', value);\n        }\n        else if (value instanceof Date) {\n            this.#payload.exp = validateInput('setExpirationTime', epoch(value));\n        }\n        else {\n            this.#payload.exp = epoch(new Date()) + secs(value);\n        }\n    }\n    set iat(value) {\n        if (value === undefined) {\n            this.#payload.iat = epoch(new Date());\n        }\n        else if (value instanceof Date) {\n            this.#payload.iat = validateInput('setIssuedAt', epoch(value));\n        }\n        else if (typeof value === 'string') {\n            this.#payload.iat = validateInput('setIssuedAt', epoch(new Date()) + secs(value));\n        }\n        else {\n            this.#payload.iat = validateInput('setIssuedAt', value);\n        }\n    }\n}\n","import { CompactSign } from '../jws/compact/sign.js';\nimport { JWTInvalid } from '../util/errors.js';\nimport { JWTClaimsBuilder } from '../lib/jwt_claims_set.js';\nexport class SignJWT {\n    #protectedHeader;\n    #jwt;\n    constructor(payload = {}) {\n        this.#jwt = new JWTClaimsBuilder(payload);\n    }\n    setIssuer(issuer) {\n        this.#jwt.iss = issuer;\n        return this;\n    }\n    setSubject(subject) {\n        this.#jwt.sub = subject;\n        return this;\n    }\n    setAudience(audience) {\n        this.#jwt.aud = audience;\n        return this;\n    }\n    setJti(jwtId) {\n        this.#jwt.jti = jwtId;\n        return this;\n    }\n    setNotBefore(input) {\n        this.#jwt.nbf = input;\n        return this;\n    }\n    setExpirationTime(input) {\n        this.#jwt.exp = input;\n        return this;\n    }\n    setIssuedAt(input) {\n        this.#jwt.iat = input;\n        return this;\n    }\n    setProtectedHeader(protectedHeader) {\n        this.#protectedHeader = protectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        const sig = new CompactSign(this.#jwt.data());\n        sig.setProtectedHeader(this.#protectedHeader);\n        if (Array.isArray(this.#protectedHeader?.crit) &&\n            this.#protectedHeader.crit.includes('b64') &&\n            this.#protectedHeader.b64 === false) {\n            throw new JWTInvalid('JWTs MUST NOT use unencoded payload');\n        }\n        return sig.sign(key, options);\n    }\n}\n","import { SignJWT, importPKCS8 } from 'jose';\nconst payload = (issuerId, duration)=>({\n        audience: 'appstoreconnect-v1',\n        expiresIn: duration,\n        issuer: issuerId\n    });\n/**\n * Synchronous token generation.\n * @deprecated Use `token` instead.\n * \n * @param privateKey\n * @param issuerId \n * @param privateKeyId \n * @param duration \n * @returns \n */ export function tokenSync(privateKey, issuerId, privateKeyId, duration = 500) {\n    let result;\n    token(privateKey, issuerId, privateKeyId, duration).then((token)=>{\n        result = token;\n        return token;\n    }).catch((error)=>{\n        throw new Error(`Failed to generate token: ${error.message}`);\n    });\n    return result ?? '';\n}\n/**\n * Asynchronous token generation.\n * @param privateKey \n * @param issuerId \n * @param privateKeyId \n * @param duration \n * @returns \n */ export async function token(privateKey, issuerId, privateKeyId, duration = 500) {\n    try {\n        const key = await importPKCS8(privateKey.toString(), 'ES256');\n        return new SignJWT(payload(issuerId, duration)).setProtectedHeader({\n            alg: 'ES256',\n            kid: privateKeyId\n        }).sign(key);\n    } catch (error) {\n        if (error instanceof Error) {\n            // Use predefined error messages to avoid information leakage\n            if (error.message.includes('PKCS8')) {\n                throw new Error('JWT token generation failed: Invalid key format');\n            } else if (error.message.includes('sign')) {\n                throw new Error('JWT token generation failed: Signing operation failed');\n            }\n            throw new Error('JWT token generation failed: Internal error');\n        }\n        throw new Error('JWT token generation failed: Unknown error occurred');\n    }\n}\nconst jwtGenCore = {\n    tokenSync,\n    token\n};\nexport default jwtGenCore;\n\n","import { token } from 'appstore-connect-jwt-generator-core';\nimport 'source-map-support/register';\nconst main = {\n    main: () => {\n        console.log(typeof token);\n    }\n};\nexport default main;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5tanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvbWFpbi5tdHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLHFDQUFxQyxDQUFDO0FBQzVELE9BQU8sNkJBQTZCLENBQUM7QUFFckMsTUFBTSxJQUFJLEdBQUc7SUFDVCxJQUFJLEVBQUUsR0FBRyxFQUFFO1FBQ1AsT0FBTyxDQUFDLEdBQUcsQ0FBQyxPQUFPLEtBQUssQ0FBQyxDQUFDO0lBQzlCLENBQUM7Q0FDSixDQUFDO0FBRUYsZUFBZSxJQUFJLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB0b2tlbiB9IGZyb20gJ2FwcHN0b3JlLWNvbm5lY3Qtand0LWdlbmVyYXRvci1jb3JlJztcbmltcG9ydCAnc291cmNlLW1hcC1zdXBwb3J0L3JlZ2lzdGVyJztcblxuY29uc3QgbWFpbiA9IHtcbiAgICBtYWluOiAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKHR5cGVvZiB0b2tlbik7XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgbWFpbjsiXX0="],"mappings":"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","ignoreList":[]}