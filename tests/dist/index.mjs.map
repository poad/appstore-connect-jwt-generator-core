{"version":3,"file":"index.mjs","names":["module","exports","eval","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","threw","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","ab","URL","url","pathname","slice","match","base64_encodeBase64","input","Uint8Array","toBase64","CHUNK_SIZE","arr","i","length","push","String","fromCharCode","apply","subarray","btoa","join","decodeBase64","encoded","fromBase64","binary","atob","bytes","charCodeAt","JOSEError","Error","static","code","constructor","message","options","super","this","name","captureStackTrace","errors_JWTClaimValidationFailed","claim","reason","payload","cause","errors_JWTExpired","JOSEAlgNotAllowed","errors_JOSENotSupported","JWEDecryptionFailed","JWEInvalid","JWSInvalid","errors_JWTInvalid","JWKInvalid","JWKSInvalid","JWKSNoMatchingKey","JWKSMultipleMatchingKeys","Symbol","asyncIterator","JWKSTimeout","JWSSignatureVerificationFailed","formatPEM","b64","descriptor","newlined","genericExport","async","keyType","keyFormat","isKeyObject","type","TypeError","export","format","isCryptoKey","invalidKeyInput","extractable","encodeBase64","crypto","subtle","exportKey","toUpperCase","toSPKI","toPKCS8","bytesEqual","a","b","byteLength","createASN1State","data","pos","parseLength","state","first","lengthOfLen","skipElement","count","expectTag","expectedTag","errorMessage","getSubarray","result","parseAlgorithmOID","oidLen","parsePKCS8Header","verLen","algIdLen","algIdStart","algIdLength","parseSPKIHeader","parseECAlgorithmIdentifier","algOid","curveOidLen","curveOid","oid","genericImport","keyData","alg","algorithm","keyUsages","isPublic","getSigUsages","getEncUsages","hash","parseInt","curveMap","ES256","ES384","ES512","namedCurve","getNamedCurve","importKey","processPEMData","pem","pattern","replace","fromPKCS8","opts","startsWith","asn1_fromSPKI","spkiFromX509","buf","spkiStart","spkiContentLen","extractX509SPKI","x509","derBytes","asn1_fromX509","spki","importSPKI","indexOf","fromSPKI","importX509","fromX509","importPKCS8","pkcs8","importJWK","jwk","isObject","ext","kty","k","decodeBase64URL","oth","JOSENotSupported","toCryptoKey","encoder","TextEncoder","buffer_utils_decoder","TextDecoder","MAX_INT32","concat","buffers","size","reduce","acc","buffer","set","writeUInt32BE","value","offset","RangeError","uint64be","high","Math","floor","low","uint32be","decode","alphabet","encode","unencoded","omitPadding","subtle_dsa","saltLength","check_key_length","modulusLength","unusable","isAlgorithm","getHashLength","checkUsage","usage","usages","includes","checkSigCryptoKey","expected","actual","checkEncCryptoKey","msg","types","filter","Boolean","last","pop","invalid_key_input","withAlg","get_sign_verify_key","sign","cryptoKey","signature","is_disjoint","headers","sources","header","parameters","keys","Set","parameter","has","add","assertCryptoKey","is_key_like_isCryptoKey","toStringTag","is_key_like_isKeyObject","is_key_like","isObjectLike","is_object","toString","getPrototypeOf","proto","isJWK","isPrivateJWK","priv","isPublicJWK","isSecretJWK","tag","jwkMatchesOp","use","Array","isArray","key_ops","expectedKeyOp","test","endsWith","symmetricTypeCheck","asymmetricTypeCheck","check_key_type","symmetric","validate_crit","Err","recognizedDefault","recognizedOption","protectedHeader","joseHeader","crit","some","recognized","Map","entries","subtleMapping","crv","jwk_to_key","cache","handleJWK","freeze","WeakMap","cached","handleKeyObject","keyObject","asymmetricKeyType","nist","asymmetricKeyDetails","normalize_key","err","FlattenedSign","unprotectedHeader","setProtectedHeader","setUnprotectedHeader","extensions","JSON","stringify","jws","protected","CompactSign","flattened","lib_epoch","date","getTime","minute","hour","day","week","year","REGEX","lib_secs","str","matched","exec","parseFloat","unit","toLowerCase","numericDate","round","validateInput","label","Number","isFinite","normalizeTyp","checkAudiencePresence","audPayload","audOption","bind","validateClaimsSet","encodedPayload","parse","decoder","JWTInvalid","typ","JWTClaimValidationFailed","requiredClaims","issuer","subject","audience","maxTokenAge","presenceCheck","reverse","iss","sub","aud","tolerance","clockTolerance","secs","currentDate","now","epoch","Date","iat","nbf","exp","JWTExpired","age","max","JWTClaimsBuilder","structuredClone","jti","SignJWT","jwt","setIssuer","setSubject","setAudience","setJti","jwtId","setNotBefore","setExpirationTime","setIssuedAt","sig","issuerId","duration","expiresIn","tokenSync","privateKey","privateKeyId","token","then","catch","error","kid","jwtGenCore","esm","main","console","log","esm_main"],"sources":["../../node_modules/.pnpm/@vercel+ncc@0.38.3/node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../webpack/bootstrap","../webpack/runtime/define property getters","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/compat","../../node_modules/.pnpm/jose@6.1.0/node_modules/jose/dist/webapi/lib/base64.js","../../node_modules/.pnpm/jose@6.1.0/node_modules/jose/dist/webapi/util/errors.js","../../node_modules/.pnpm/jose@6.1.0/node_modules/jose/dist/webapi/lib/asn1.js","../../node_modules/.pnpm/jose@6.1.0/node_modules/jose/dist/webapi/key/import.js","../../node_modules/.pnpm/jose@6.1.0/node_modules/jose/dist/webapi/lib/buffer_utils.js","../../node_modules/.pnpm/jose@6.1.0/node_modules/jose/dist/webapi/util/base64url.js","../../node_modules/.pnpm/jose@6.1.0/node_modules/jose/dist/webapi/lib/subtle_dsa.js","../../node_modules/.pnpm/jose@6.1.0/node_modules/jose/dist/webapi/lib/check_key_length.js","../../node_modules/.pnpm/jose@6.1.0/node_modules/jose/dist/webapi/lib/crypto_key.js","../../node_modules/.pnpm/jose@6.1.0/node_modules/jose/dist/webapi/lib/invalid_key_input.js","../../node_modules/.pnpm/jose@6.1.0/node_modules/jose/dist/webapi/lib/get_sign_verify_key.js","../../node_modules/.pnpm/jose@6.1.0/node_modules/jose/dist/webapi/lib/sign.js","../../node_modules/.pnpm/jose@6.1.0/node_modules/jose/dist/webapi/lib/is_disjoint.js","../../node_modules/.pnpm/jose@6.1.0/node_modules/jose/dist/webapi/lib/is_key_like.js","../../node_modules/.pnpm/jose@6.1.0/node_modules/jose/dist/webapi/lib/is_object.js","../../node_modules/.pnpm/jose@6.1.0/node_modules/jose/dist/webapi/lib/is_jwk.js","../../node_modules/.pnpm/jose@6.1.0/node_modules/jose/dist/webapi/lib/check_key_type.js","../../node_modules/.pnpm/jose@6.1.0/node_modules/jose/dist/webapi/lib/validate_crit.js","../../node_modules/.pnpm/jose@6.1.0/node_modules/jose/dist/webapi/lib/jwk_to_key.js","../../node_modules/.pnpm/jose@6.1.0/node_modules/jose/dist/webapi/lib/normalize_key.js","../../node_modules/.pnpm/jose@6.1.0/node_modules/jose/dist/webapi/jws/flattened/sign.js","../../node_modules/.pnpm/jose@6.1.0/node_modules/jose/dist/webapi/jws/compact/sign.js","../../node_modules/.pnpm/jose@6.1.0/node_modules/jose/dist/webapi/lib/epoch.js","../../node_modules/.pnpm/jose@6.1.0/node_modules/jose/dist/webapi/lib/secs.js","../../node_modules/.pnpm/jose@6.1.0/node_modules/jose/dist/webapi/lib/jwt_claims_set.js","../../node_modules/.pnpm/jose@6.1.0/node_modules/jose/dist/webapi/jwt/sign.js","../../package/esm/index.js","../esm/main.mjs"],"sourcesContent":[null,"// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = new URL('.', import.meta.url).pathname.slice(import.meta.url.match(/^file:\\/\\/\\/\\w:/) ? 1 : 0, -1) + \"/\";","export function encodeBase64(input) {\n    if (Uint8Array.prototype.toBase64) {\n        return input.toBase64();\n    }\n    const CHUNK_SIZE = 0x8000;\n    const arr = [];\n    for (let i = 0; i < input.length; i += CHUNK_SIZE) {\n        arr.push(String.fromCharCode.apply(null, input.subarray(i, i + CHUNK_SIZE)));\n    }\n    return btoa(arr.join(''));\n}\nexport function decodeBase64(encoded) {\n    if (Uint8Array.fromBase64) {\n        return Uint8Array.fromBase64(encoded);\n    }\n    const binary = atob(encoded);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n}\n","export class JOSEError extends Error {\n    static code = 'ERR_JOSE_GENERIC';\n    code = 'ERR_JOSE_GENERIC';\n    constructor(message, options) {\n        super(message, options);\n        this.name = this.constructor.name;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nexport class JWTClaimValidationFailed extends JOSEError {\n    static code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n    code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n    claim;\n    reason;\n    payload;\n    constructor(message, payload, claim = 'unspecified', reason = 'unspecified') {\n        super(message, { cause: { claim, reason, payload } });\n        this.claim = claim;\n        this.reason = reason;\n        this.payload = payload;\n    }\n}\nexport class JWTExpired extends JOSEError {\n    static code = 'ERR_JWT_EXPIRED';\n    code = 'ERR_JWT_EXPIRED';\n    claim;\n    reason;\n    payload;\n    constructor(message, payload, claim = 'unspecified', reason = 'unspecified') {\n        super(message, { cause: { claim, reason, payload } });\n        this.claim = claim;\n        this.reason = reason;\n        this.payload = payload;\n    }\n}\nexport class JOSEAlgNotAllowed extends JOSEError {\n    static code = 'ERR_JOSE_ALG_NOT_ALLOWED';\n    code = 'ERR_JOSE_ALG_NOT_ALLOWED';\n}\nexport class JOSENotSupported extends JOSEError {\n    static code = 'ERR_JOSE_NOT_SUPPORTED';\n    code = 'ERR_JOSE_NOT_SUPPORTED';\n}\nexport class JWEDecryptionFailed extends JOSEError {\n    static code = 'ERR_JWE_DECRYPTION_FAILED';\n    code = 'ERR_JWE_DECRYPTION_FAILED';\n    constructor(message = 'decryption operation failed', options) {\n        super(message, options);\n    }\n}\nexport class JWEInvalid extends JOSEError {\n    static code = 'ERR_JWE_INVALID';\n    code = 'ERR_JWE_INVALID';\n}\nexport class JWSInvalid extends JOSEError {\n    static code = 'ERR_JWS_INVALID';\n    code = 'ERR_JWS_INVALID';\n}\nexport class JWTInvalid extends JOSEError {\n    static code = 'ERR_JWT_INVALID';\n    code = 'ERR_JWT_INVALID';\n}\nexport class JWKInvalid extends JOSEError {\n    static code = 'ERR_JWK_INVALID';\n    code = 'ERR_JWK_INVALID';\n}\nexport class JWKSInvalid extends JOSEError {\n    static code = 'ERR_JWKS_INVALID';\n    code = 'ERR_JWKS_INVALID';\n}\nexport class JWKSNoMatchingKey extends JOSEError {\n    static code = 'ERR_JWKS_NO_MATCHING_KEY';\n    code = 'ERR_JWKS_NO_MATCHING_KEY';\n    constructor(message = 'no applicable key found in the JSON Web Key Set', options) {\n        super(message, options);\n    }\n}\nexport class JWKSMultipleMatchingKeys extends JOSEError {\n    [Symbol.asyncIterator];\n    static code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n    code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n    constructor(message = 'multiple matching keys found in the JSON Web Key Set', options) {\n        super(message, options);\n    }\n}\nexport class JWKSTimeout extends JOSEError {\n    static code = 'ERR_JWKS_TIMEOUT';\n    code = 'ERR_JWKS_TIMEOUT';\n    constructor(message = 'request timed out', options) {\n        super(message, options);\n    }\n}\nexport class JWSSignatureVerificationFailed extends JOSEError {\n    static code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n    code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n    constructor(message = 'signature verification failed', options) {\n        super(message, options);\n    }\n}\n","import invalidKeyInput from './invalid_key_input.js';\nimport { encodeBase64, decodeBase64 } from '../lib/base64.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport { isCryptoKey, isKeyObject } from './is_key_like.js';\nconst formatPEM = (b64, descriptor) => {\n    const newlined = (b64.match(/.{1,64}/g) || []).join('\\n');\n    return `-----BEGIN ${descriptor}-----\\n${newlined}\\n-----END ${descriptor}-----`;\n};\nconst genericExport = async (keyType, keyFormat, key) => {\n    if (isKeyObject(key)) {\n        if (key.type !== keyType) {\n            throw new TypeError(`key is not a ${keyType} key`);\n        }\n        return key.export({ format: 'pem', type: keyFormat });\n    }\n    if (!isCryptoKey(key)) {\n        throw new TypeError(invalidKeyInput(key, 'CryptoKey', 'KeyObject'));\n    }\n    if (!key.extractable) {\n        throw new TypeError('CryptoKey is not extractable');\n    }\n    if (key.type !== keyType) {\n        throw new TypeError(`key is not a ${keyType} key`);\n    }\n    return formatPEM(encodeBase64(new Uint8Array(await crypto.subtle.exportKey(keyFormat, key))), `${keyType.toUpperCase()} KEY`);\n};\nexport const toSPKI = (key) => {\n    return genericExport('public', 'spki', key);\n};\nexport const toPKCS8 = (key) => {\n    return genericExport('private', 'pkcs8', key);\n};\nconst bytesEqual = (a, b) => {\n    if (a.byteLength !== b.length)\n        return false;\n    for (let i = 0; i < a.byteLength; i++) {\n        if (a[i] !== b[i])\n            return false;\n    }\n    return true;\n};\nconst createASN1State = (data) => ({ data, pos: 0 });\nconst parseLength = (state) => {\n    const first = state.data[state.pos++];\n    if (first & 0x80) {\n        const lengthOfLen = first & 0x7f;\n        let length = 0;\n        for (let i = 0; i < lengthOfLen; i++) {\n            length = (length << 8) | state.data[state.pos++];\n        }\n        return length;\n    }\n    return first;\n};\nconst skipElement = (state, count = 1) => {\n    if (count <= 0)\n        return;\n    state.pos++;\n    const length = parseLength(state);\n    state.pos += length;\n    if (count > 1) {\n        skipElement(state, count - 1);\n    }\n};\nconst expectTag = (state, expectedTag, errorMessage) => {\n    if (state.data[state.pos++] !== expectedTag) {\n        throw new Error(errorMessage);\n    }\n};\nconst getSubarray = (state, length) => {\n    const result = state.data.subarray(state.pos, state.pos + length);\n    state.pos += length;\n    return result;\n};\nconst parseAlgorithmOID = (state) => {\n    expectTag(state, 0x06, 'Expected algorithm OID');\n    const oidLen = parseLength(state);\n    return getSubarray(state, oidLen);\n};\nfunction parsePKCS8Header(state) {\n    expectTag(state, 0x30, 'Invalid PKCS#8 structure');\n    parseLength(state);\n    expectTag(state, 0x02, 'Expected version field');\n    const verLen = parseLength(state);\n    state.pos += verLen;\n    expectTag(state, 0x30, 'Expected algorithm identifier');\n    const algIdLen = parseLength(state);\n    const algIdStart = state.pos;\n    return { algIdStart, algIdLength: algIdLen };\n}\nfunction parseSPKIHeader(state) {\n    expectTag(state, 0x30, 'Invalid SPKI structure');\n    parseLength(state);\n    expectTag(state, 0x30, 'Expected algorithm identifier');\n    const algIdLen = parseLength(state);\n    const algIdStart = state.pos;\n    return { algIdStart, algIdLength: algIdLen };\n}\nconst parseECAlgorithmIdentifier = (state) => {\n    const algOid = parseAlgorithmOID(state);\n    if (bytesEqual(algOid, [0x2b, 0x65, 0x6e])) {\n        return 'X25519';\n    }\n    if (!bytesEqual(algOid, [0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01])) {\n        throw new Error('Unsupported key algorithm');\n    }\n    expectTag(state, 0x06, 'Expected curve OID');\n    const curveOidLen = parseLength(state);\n    const curveOid = getSubarray(state, curveOidLen);\n    for (const { name, oid } of [\n        { name: 'P-256', oid: [0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07] },\n        { name: 'P-384', oid: [0x2b, 0x81, 0x04, 0x00, 0x22] },\n        { name: 'P-521', oid: [0x2b, 0x81, 0x04, 0x00, 0x23] },\n    ]) {\n        if (bytesEqual(curveOid, oid)) {\n            return name;\n        }\n    }\n    throw new Error('Unsupported named curve');\n};\nconst genericImport = async (keyFormat, keyData, alg, options) => {\n    let algorithm;\n    let keyUsages;\n    const isPublic = keyFormat === 'spki';\n    const getSigUsages = () => (isPublic ? ['verify'] : ['sign']);\n    const getEncUsages = () => isPublic ? ['encrypt', 'wrapKey'] : ['decrypt', 'unwrapKey'];\n    switch (alg) {\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n            algorithm = { name: 'RSA-PSS', hash: `SHA-${alg.slice(-3)}` };\n            keyUsages = getSigUsages();\n            break;\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            algorithm = { name: 'RSASSA-PKCS1-v1_5', hash: `SHA-${alg.slice(-3)}` };\n            keyUsages = getSigUsages();\n            break;\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512':\n            algorithm = {\n                name: 'RSA-OAEP',\n                hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`,\n            };\n            keyUsages = getEncUsages();\n            break;\n        case 'ES256':\n        case 'ES384':\n        case 'ES512': {\n            const curveMap = { ES256: 'P-256', ES384: 'P-384', ES512: 'P-521' };\n            algorithm = { name: 'ECDSA', namedCurve: curveMap[alg] };\n            keyUsages = getSigUsages();\n            break;\n        }\n        case 'ECDH-ES':\n        case 'ECDH-ES+A128KW':\n        case 'ECDH-ES+A192KW':\n        case 'ECDH-ES+A256KW': {\n            try {\n                const namedCurve = options.getNamedCurve(keyData);\n                algorithm = namedCurve === 'X25519' ? { name: 'X25519' } : { name: 'ECDH', namedCurve };\n            }\n            catch (cause) {\n                throw new JOSENotSupported('Invalid or unsupported key format');\n            }\n            keyUsages = isPublic ? [] : ['deriveBits'];\n            break;\n        }\n        case 'Ed25519':\n        case 'EdDSA':\n            algorithm = { name: 'Ed25519' };\n            keyUsages = getSigUsages();\n            break;\n        case 'ML-DSA-44':\n        case 'ML-DSA-65':\n        case 'ML-DSA-87':\n            algorithm = { name: alg };\n            keyUsages = getSigUsages();\n            break;\n        default:\n            throw new JOSENotSupported('Invalid or unsupported \"alg\" (Algorithm) value');\n    }\n    return crypto.subtle.importKey(keyFormat, keyData, algorithm, options?.extractable ?? (isPublic ? true : false), keyUsages);\n};\nconst processPEMData = (pem, pattern) => {\n    return decodeBase64(pem.replace(pattern, ''));\n};\nexport const fromPKCS8 = (pem, alg, options) => {\n    const keyData = processPEMData(pem, /(?:-----(?:BEGIN|END) PRIVATE KEY-----|\\s)/g);\n    let opts = options;\n    if (alg?.startsWith?.('ECDH-ES')) {\n        opts ||= {};\n        opts.getNamedCurve = (keyData) => {\n            const state = createASN1State(keyData);\n            parsePKCS8Header(state);\n            return parseECAlgorithmIdentifier(state);\n        };\n    }\n    return genericImport('pkcs8', keyData, alg, opts);\n};\nexport const fromSPKI = (pem, alg, options) => {\n    const keyData = processPEMData(pem, /(?:-----(?:BEGIN|END) PUBLIC KEY-----|\\s)/g);\n    let opts = options;\n    if (alg?.startsWith?.('ECDH-ES')) {\n        opts ||= {};\n        opts.getNamedCurve = (keyData) => {\n            const state = createASN1State(keyData);\n            parseSPKIHeader(state);\n            return parseECAlgorithmIdentifier(state);\n        };\n    }\n    return genericImport('spki', keyData, alg, opts);\n};\nfunction spkiFromX509(buf) {\n    const state = createASN1State(buf);\n    expectTag(state, 0x30, 'Invalid certificate structure');\n    parseLength(state);\n    expectTag(state, 0x30, 'Invalid tbsCertificate structure');\n    parseLength(state);\n    if (buf[state.pos] === 0xa0) {\n        skipElement(state, 6);\n    }\n    else {\n        skipElement(state, 5);\n    }\n    const spkiStart = state.pos;\n    expectTag(state, 0x30, 'Invalid SPKI structure');\n    const spkiContentLen = parseLength(state);\n    return buf.subarray(spkiStart, spkiStart + spkiContentLen + (state.pos - spkiStart));\n}\nfunction extractX509SPKI(x509) {\n    const derBytes = processPEMData(x509, /(?:-----(?:BEGIN|END) CERTIFICATE-----|\\s)/g);\n    return spkiFromX509(derBytes);\n}\nexport const fromX509 = (pem, alg, options) => {\n    let spki;\n    try {\n        spki = extractX509SPKI(pem);\n    }\n    catch (cause) {\n        throw new TypeError('Failed to parse the X.509 certificate', { cause });\n    }\n    return fromSPKI(formatPEM(encodeBase64(spki), 'PUBLIC KEY'), alg, options);\n};\n","import { decode as decodeBase64URL } from '../util/base64url.js';\nimport { fromSPKI, fromPKCS8, fromX509 } from '../lib/asn1.js';\nimport toCryptoKey from '../lib/jwk_to_key.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport isObject from '../lib/is_object.js';\nexport async function importSPKI(spki, alg, options) {\n    if (typeof spki !== 'string' || spki.indexOf('-----BEGIN PUBLIC KEY-----') !== 0) {\n        throw new TypeError('\"spki\" must be SPKI formatted string');\n    }\n    return fromSPKI(spki, alg, options);\n}\nexport async function importX509(x509, alg, options) {\n    if (typeof x509 !== 'string' || x509.indexOf('-----BEGIN CERTIFICATE-----') !== 0) {\n        throw new TypeError('\"x509\" must be X.509 formatted string');\n    }\n    return fromX509(x509, alg, options);\n}\nexport async function importPKCS8(pkcs8, alg, options) {\n    if (typeof pkcs8 !== 'string' || pkcs8.indexOf('-----BEGIN PRIVATE KEY-----') !== 0) {\n        throw new TypeError('\"pkcs8\" must be PKCS#8 formatted string');\n    }\n    return fromPKCS8(pkcs8, alg, options);\n}\nexport async function importJWK(jwk, alg, options) {\n    if (!isObject(jwk)) {\n        throw new TypeError('JWK must be an object');\n    }\n    let ext;\n    alg ??= jwk.alg;\n    ext ??= options?.extractable ?? jwk.ext;\n    switch (jwk.kty) {\n        case 'oct':\n            if (typeof jwk.k !== 'string' || !jwk.k) {\n                throw new TypeError('missing \"k\" (Key Value) Parameter value');\n            }\n            return decodeBase64URL(jwk.k);\n        case 'RSA':\n            if ('oth' in jwk && jwk.oth !== undefined) {\n                throw new JOSENotSupported('RSA JWK \"oth\" (Other Primes Info) Parameter value is not supported');\n            }\n            return toCryptoKey({ ...jwk, alg, ext });\n        case 'AKP': {\n            if (typeof jwk.alg !== 'string' || !jwk.alg) {\n                throw new TypeError('missing \"alg\" (Algorithm) Parameter value');\n            }\n            if (alg !== undefined && alg !== jwk.alg) {\n                throw new TypeError('JWK alg and alg option value mismatch');\n            }\n            return toCryptoKey({ ...jwk, ext });\n        }\n        case 'EC':\n        case 'OKP':\n            return toCryptoKey({ ...jwk, alg, ext });\n        default:\n            throw new JOSENotSupported('Unsupported \"kty\" (Key Type) Parameter value');\n    }\n}\n","export const encoder = new TextEncoder();\nexport const decoder = new TextDecoder();\nconst MAX_INT32 = 2 ** 32;\nexport function concat(...buffers) {\n    const size = buffers.reduce((acc, { length }) => acc + length, 0);\n    const buf = new Uint8Array(size);\n    let i = 0;\n    for (const buffer of buffers) {\n        buf.set(buffer, i);\n        i += buffer.length;\n    }\n    return buf;\n}\nfunction writeUInt32BE(buf, value, offset) {\n    if (value < 0 || value >= MAX_INT32) {\n        throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);\n    }\n    buf.set([value >>> 24, value >>> 16, value >>> 8, value & 0xff], offset);\n}\nexport function uint64be(value) {\n    const high = Math.floor(value / MAX_INT32);\n    const low = value % MAX_INT32;\n    const buf = new Uint8Array(8);\n    writeUInt32BE(buf, high, 0);\n    writeUInt32BE(buf, low, 4);\n    return buf;\n}\nexport function uint32be(value) {\n    const buf = new Uint8Array(4);\n    writeUInt32BE(buf, value);\n    return buf;\n}\n","import { encoder, decoder } from '../lib/buffer_utils.js';\nimport { encodeBase64, decodeBase64 } from '../lib/base64.js';\nexport function decode(input) {\n    if (Uint8Array.fromBase64) {\n        return Uint8Array.fromBase64(typeof input === 'string' ? input : decoder.decode(input), {\n            alphabet: 'base64url',\n        });\n    }\n    let encoded = input;\n    if (encoded instanceof Uint8Array) {\n        encoded = decoder.decode(encoded);\n    }\n    encoded = encoded.replace(/-/g, '+').replace(/_/g, '/').replace(/\\s/g, '');\n    try {\n        return decodeBase64(encoded);\n    }\n    catch {\n        throw new TypeError('The input to be decoded is not correctly encoded.');\n    }\n}\nexport function encode(input) {\n    let unencoded = input;\n    if (typeof unencoded === 'string') {\n        unencoded = encoder.encode(unencoded);\n    }\n    if (Uint8Array.prototype.toBase64) {\n        return unencoded.toBase64({ alphabet: 'base64url', omitPadding: true });\n    }\n    return encodeBase64(unencoded).replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n}\n","import { JOSENotSupported } from '../util/errors.js';\nexport default (alg, algorithm) => {\n    const hash = `SHA-${alg.slice(-3)}`;\n    switch (alg) {\n        case 'HS256':\n        case 'HS384':\n        case 'HS512':\n            return { hash, name: 'HMAC' };\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n            return { hash, name: 'RSA-PSS', saltLength: parseInt(alg.slice(-3), 10) >> 3 };\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            return { hash, name: 'RSASSA-PKCS1-v1_5' };\n        case 'ES256':\n        case 'ES384':\n        case 'ES512':\n            return { hash, name: 'ECDSA', namedCurve: algorithm.namedCurve };\n        case 'Ed25519':\n        case 'EdDSA':\n            return { name: 'Ed25519' };\n        case 'ML-DSA-44':\n        case 'ML-DSA-65':\n        case 'ML-DSA-87':\n            return { name: alg };\n        default:\n            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);\n    }\n};\n","export default (alg, key) => {\n    if (alg.startsWith('RS') || alg.startsWith('PS')) {\n        const { modulusLength } = key.algorithm;\n        if (typeof modulusLength !== 'number' || modulusLength < 2048) {\n            throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);\n        }\n    }\n};\n","function unusable(name, prop = 'algorithm.name') {\n    return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);\n}\nfunction isAlgorithm(algorithm, name) {\n    return algorithm.name === name;\n}\nfunction getHashLength(hash) {\n    return parseInt(hash.name.slice(4), 10);\n}\nfunction getNamedCurve(alg) {\n    switch (alg) {\n        case 'ES256':\n            return 'P-256';\n        case 'ES384':\n            return 'P-384';\n        case 'ES512':\n            return 'P-521';\n        default:\n            throw new Error('unreachable');\n    }\n}\nfunction checkUsage(key, usage) {\n    if (usage && !key.usages.includes(usage)) {\n        throw new TypeError(`CryptoKey does not support this operation, its usages must include ${usage}.`);\n    }\n}\nexport function checkSigCryptoKey(key, alg, usage) {\n    switch (alg) {\n        case 'HS256':\n        case 'HS384':\n        case 'HS512': {\n            if (!isAlgorithm(key.algorithm, 'HMAC'))\n                throw unusable('HMAC');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'RS256':\n        case 'RS384':\n        case 'RS512': {\n            if (!isAlgorithm(key.algorithm, 'RSASSA-PKCS1-v1_5'))\n                throw unusable('RSASSA-PKCS1-v1_5');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'PS256':\n        case 'PS384':\n        case 'PS512': {\n            if (!isAlgorithm(key.algorithm, 'RSA-PSS'))\n                throw unusable('RSA-PSS');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'Ed25519':\n        case 'EdDSA': {\n            if (!isAlgorithm(key.algorithm, 'Ed25519'))\n                throw unusable('Ed25519');\n            break;\n        }\n        case 'ML-DSA-44':\n        case 'ML-DSA-65':\n        case 'ML-DSA-87': {\n            if (!isAlgorithm(key.algorithm, alg))\n                throw unusable(alg);\n            break;\n        }\n        case 'ES256':\n        case 'ES384':\n        case 'ES512': {\n            if (!isAlgorithm(key.algorithm, 'ECDSA'))\n                throw unusable('ECDSA');\n            const expected = getNamedCurve(alg);\n            const actual = key.algorithm.namedCurve;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.namedCurve');\n            break;\n        }\n        default:\n            throw new TypeError('CryptoKey does not support this operation');\n    }\n    checkUsage(key, usage);\n}\nexport function checkEncCryptoKey(key, alg, usage) {\n    switch (alg) {\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM': {\n            if (!isAlgorithm(key.algorithm, 'AES-GCM'))\n                throw unusable('AES-GCM');\n            const expected = parseInt(alg.slice(1, 4), 10);\n            const actual = key.algorithm.length;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.length');\n            break;\n        }\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW': {\n            if (!isAlgorithm(key.algorithm, 'AES-KW'))\n                throw unusable('AES-KW');\n            const expected = parseInt(alg.slice(1, 4), 10);\n            const actual = key.algorithm.length;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.length');\n            break;\n        }\n        case 'ECDH': {\n            switch (key.algorithm.name) {\n                case 'ECDH':\n                case 'X25519':\n                    break;\n                default:\n                    throw unusable('ECDH or X25519');\n            }\n            break;\n        }\n        case 'PBES2-HS256+A128KW':\n        case 'PBES2-HS384+A192KW':\n        case 'PBES2-HS512+A256KW':\n            if (!isAlgorithm(key.algorithm, 'PBKDF2'))\n                throw unusable('PBKDF2');\n            break;\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512': {\n            if (!isAlgorithm(key.algorithm, 'RSA-OAEP'))\n                throw unusable('RSA-OAEP');\n            const expected = parseInt(alg.slice(9), 10) || 1;\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        default:\n            throw new TypeError('CryptoKey does not support this operation');\n    }\n    checkUsage(key, usage);\n}\n","function message(msg, actual, ...types) {\n    types = types.filter(Boolean);\n    if (types.length > 2) {\n        const last = types.pop();\n        msg += `one of type ${types.join(', ')}, or ${last}.`;\n    }\n    else if (types.length === 2) {\n        msg += `one of type ${types[0]} or ${types[1]}.`;\n    }\n    else {\n        msg += `of type ${types[0]}.`;\n    }\n    if (actual == null) {\n        msg += ` Received ${actual}`;\n    }\n    else if (typeof actual === 'function' && actual.name) {\n        msg += ` Received function ${actual.name}`;\n    }\n    else if (typeof actual === 'object' && actual != null) {\n        if (actual.constructor?.name) {\n            msg += ` Received an instance of ${actual.constructor.name}`;\n        }\n    }\n    return msg;\n}\nexport default (actual, ...types) => {\n    return message('Key must be ', actual, ...types);\n};\nexport function withAlg(alg, actual, ...types) {\n    return message(`Key for the ${alg} algorithm must be `, actual, ...types);\n}\n","import { checkSigCryptoKey } from './crypto_key.js';\nimport invalidKeyInput from './invalid_key_input.js';\nexport default async (alg, key, usage) => {\n    if (key instanceof Uint8Array) {\n        if (!alg.startsWith('HS')) {\n            throw new TypeError(invalidKeyInput(key, 'CryptoKey', 'KeyObject', 'JSON Web Key'));\n        }\n        return crypto.subtle.importKey('raw', key, { hash: `SHA-${alg.slice(-3)}`, name: 'HMAC' }, false, [usage]);\n    }\n    checkSigCryptoKey(key, alg, usage);\n    return key;\n};\n","import subtleAlgorithm from './subtle_dsa.js';\nimport checkKeyLength from './check_key_length.js';\nimport getSignKey from './get_sign_verify_key.js';\nexport default async (alg, key, data) => {\n    const cryptoKey = await getSignKey(alg, key, 'sign');\n    checkKeyLength(alg, cryptoKey);\n    const signature = await crypto.subtle.sign(subtleAlgorithm(alg, cryptoKey.algorithm), cryptoKey, data);\n    return new Uint8Array(signature);\n};\n","export default (...headers) => {\n    const sources = headers.filter(Boolean);\n    if (sources.length === 0 || sources.length === 1) {\n        return true;\n    }\n    let acc;\n    for (const header of sources) {\n        const parameters = Object.keys(header);\n        if (!acc || acc.size === 0) {\n            acc = new Set(parameters);\n            continue;\n        }\n        for (const parameter of parameters) {\n            if (acc.has(parameter)) {\n                return false;\n            }\n            acc.add(parameter);\n        }\n    }\n    return true;\n};\n","export function assertCryptoKey(key) {\n    if (!isCryptoKey(key)) {\n        throw new Error('CryptoKey instance expected');\n    }\n}\nexport function isCryptoKey(key) {\n    return key?.[Symbol.toStringTag] === 'CryptoKey';\n}\nexport function isKeyObject(key) {\n    return key?.[Symbol.toStringTag] === 'KeyObject';\n}\nexport default (key) => {\n    return isCryptoKey(key) || isKeyObject(key);\n};\n","function isObjectLike(value) {\n    return typeof value === 'object' && value !== null;\n}\nexport default (input) => {\n    if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') {\n        return false;\n    }\n    if (Object.getPrototypeOf(input) === null) {\n        return true;\n    }\n    let proto = input;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(input) === proto;\n};\n","import isObject from './is_object.js';\nexport function isJWK(key) {\n    return isObject(key) && typeof key.kty === 'string';\n}\nexport function isPrivateJWK(key) {\n    return (key.kty !== 'oct' &&\n        ((key.kty === 'AKP' && typeof key.priv === 'string') || typeof key.d === 'string'));\n}\nexport function isPublicJWK(key) {\n    return key.kty !== 'oct' && typeof key.d === 'undefined' && typeof key.priv === 'undefined';\n}\nexport function isSecretJWK(key) {\n    return key.kty === 'oct' && typeof key.k === 'string';\n}\n","import { withAlg as invalidKeyInput } from './invalid_key_input.js';\nimport isKeyLike from './is_key_like.js';\nimport * as jwk from './is_jwk.js';\nconst tag = (key) => key?.[Symbol.toStringTag];\nconst jwkMatchesOp = (alg, key, usage) => {\n    if (key.use !== undefined) {\n        let expected;\n        switch (usage) {\n            case 'sign':\n            case 'verify':\n                expected = 'sig';\n                break;\n            case 'encrypt':\n            case 'decrypt':\n                expected = 'enc';\n                break;\n        }\n        if (key.use !== expected) {\n            throw new TypeError(`Invalid key for this operation, its \"use\" must be \"${expected}\" when present`);\n        }\n    }\n    if (key.alg !== undefined && key.alg !== alg) {\n        throw new TypeError(`Invalid key for this operation, its \"alg\" must be \"${alg}\" when present`);\n    }\n    if (Array.isArray(key.key_ops)) {\n        let expectedKeyOp;\n        switch (true) {\n            case usage === 'sign' || usage === 'verify':\n            case alg === 'dir':\n            case alg.includes('CBC-HS'):\n                expectedKeyOp = usage;\n                break;\n            case alg.startsWith('PBES2'):\n                expectedKeyOp = 'deriveBits';\n                break;\n            case /^A\\d{3}(?:GCM)?(?:KW)?$/.test(alg):\n                if (!alg.includes('GCM') && alg.endsWith('KW')) {\n                    expectedKeyOp = usage === 'encrypt' ? 'wrapKey' : 'unwrapKey';\n                }\n                else {\n                    expectedKeyOp = usage;\n                }\n                break;\n            case usage === 'encrypt' && alg.startsWith('RSA'):\n                expectedKeyOp = 'wrapKey';\n                break;\n            case usage === 'decrypt':\n                expectedKeyOp = alg.startsWith('RSA') ? 'unwrapKey' : 'deriveBits';\n                break;\n        }\n        if (expectedKeyOp && key.key_ops?.includes?.(expectedKeyOp) === false) {\n            throw new TypeError(`Invalid key for this operation, its \"key_ops\" must include \"${expectedKeyOp}\" when present`);\n        }\n    }\n    return true;\n};\nconst symmetricTypeCheck = (alg, key, usage) => {\n    if (key instanceof Uint8Array)\n        return;\n    if (jwk.isJWK(key)) {\n        if (jwk.isSecretJWK(key) && jwkMatchesOp(alg, key, usage))\n            return;\n        throw new TypeError(`JSON Web Key for symmetric algorithms must have JWK \"kty\" (Key Type) equal to \"oct\" and the JWK \"k\" (Key Value) present`);\n    }\n    if (!isKeyLike(key)) {\n        throw new TypeError(invalidKeyInput(alg, key, 'CryptoKey', 'KeyObject', 'JSON Web Key', 'Uint8Array'));\n    }\n    if (key.type !== 'secret') {\n        throw new TypeError(`${tag(key)} instances for symmetric algorithms must be of type \"secret\"`);\n    }\n};\nconst asymmetricTypeCheck = (alg, key, usage) => {\n    if (jwk.isJWK(key)) {\n        switch (usage) {\n            case 'decrypt':\n            case 'sign':\n                if (jwk.isPrivateJWK(key) && jwkMatchesOp(alg, key, usage))\n                    return;\n                throw new TypeError(`JSON Web Key for this operation be a private JWK`);\n            case 'encrypt':\n            case 'verify':\n                if (jwk.isPublicJWK(key) && jwkMatchesOp(alg, key, usage))\n                    return;\n                throw new TypeError(`JSON Web Key for this operation be a public JWK`);\n        }\n    }\n    if (!isKeyLike(key)) {\n        throw new TypeError(invalidKeyInput(alg, key, 'CryptoKey', 'KeyObject', 'JSON Web Key'));\n    }\n    if (key.type === 'secret') {\n        throw new TypeError(`${tag(key)} instances for asymmetric algorithms must not be of type \"secret\"`);\n    }\n    if (key.type === 'public') {\n        switch (usage) {\n            case 'sign':\n                throw new TypeError(`${tag(key)} instances for asymmetric algorithm signing must be of type \"private\"`);\n            case 'decrypt':\n                throw new TypeError(`${tag(key)} instances for asymmetric algorithm decryption must be of type \"private\"`);\n            default:\n                break;\n        }\n    }\n    if (key.type === 'private') {\n        switch (usage) {\n            case 'verify':\n                throw new TypeError(`${tag(key)} instances for asymmetric algorithm verifying must be of type \"public\"`);\n            case 'encrypt':\n                throw new TypeError(`${tag(key)} instances for asymmetric algorithm encryption must be of type \"public\"`);\n            default:\n                break;\n        }\n    }\n};\nexport default (alg, key, usage) => {\n    const symmetric = alg.startsWith('HS') ||\n        alg === 'dir' ||\n        alg.startsWith('PBES2') ||\n        /^A(?:128|192|256)(?:GCM)?(?:KW)?$/.test(alg) ||\n        /^A(?:128|192|256)CBC-HS(?:256|384|512)$/.test(alg);\n    if (symmetric) {\n        symmetricTypeCheck(alg, key, usage);\n    }\n    else {\n        asymmetricTypeCheck(alg, key, usage);\n    }\n};\n","import { JOSENotSupported, JWEInvalid, JWSInvalid } from '../util/errors.js';\nexport default (Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) => {\n    if (joseHeader.crit !== undefined && protectedHeader?.crit === undefined) {\n        throw new Err('\"crit\" (Critical) Header Parameter MUST be integrity protected');\n    }\n    if (!protectedHeader || protectedHeader.crit === undefined) {\n        return new Set();\n    }\n    if (!Array.isArray(protectedHeader.crit) ||\n        protectedHeader.crit.length === 0 ||\n        protectedHeader.crit.some((input) => typeof input !== 'string' || input.length === 0)) {\n        throw new Err('\"crit\" (Critical) Header Parameter MUST be an array of non-empty strings when present');\n    }\n    let recognized;\n    if (recognizedOption !== undefined) {\n        recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);\n    }\n    else {\n        recognized = recognizedDefault;\n    }\n    for (const parameter of protectedHeader.crit) {\n        if (!recognized.has(parameter)) {\n            throw new JOSENotSupported(`Extension Header Parameter \"${parameter}\" is not recognized`);\n        }\n        if (joseHeader[parameter] === undefined) {\n            throw new Err(`Extension Header Parameter \"${parameter}\" is missing`);\n        }\n        if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {\n            throw new Err(`Extension Header Parameter \"${parameter}\" MUST be integrity protected`);\n        }\n    }\n    return new Set(protectedHeader.crit);\n};\n","import { JOSENotSupported } from '../util/errors.js';\nfunction subtleMapping(jwk) {\n    let algorithm;\n    let keyUsages;\n    switch (jwk.kty) {\n        case 'AKP': {\n            switch (jwk.alg) {\n                case 'ML-DSA-44':\n                case 'ML-DSA-65':\n                case 'ML-DSA-87':\n                    algorithm = { name: jwk.alg };\n                    keyUsages = jwk.priv ? ['sign'] : ['verify'];\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        case 'RSA': {\n            switch (jwk.alg) {\n                case 'PS256':\n                case 'PS384':\n                case 'PS512':\n                    algorithm = { name: 'RSA-PSS', hash: `SHA-${jwk.alg.slice(-3)}` };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'RS256':\n                case 'RS384':\n                case 'RS512':\n                    algorithm = { name: 'RSASSA-PKCS1-v1_5', hash: `SHA-${jwk.alg.slice(-3)}` };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'RSA-OAEP':\n                case 'RSA-OAEP-256':\n                case 'RSA-OAEP-384':\n                case 'RSA-OAEP-512':\n                    algorithm = {\n                        name: 'RSA-OAEP',\n                        hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`,\n                    };\n                    keyUsages = jwk.d ? ['decrypt', 'unwrapKey'] : ['encrypt', 'wrapKey'];\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        case 'EC': {\n            switch (jwk.alg) {\n                case 'ES256':\n                    algorithm = { name: 'ECDSA', namedCurve: 'P-256' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ES384':\n                    algorithm = { name: 'ECDSA', namedCurve: 'P-384' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ES512':\n                    algorithm = { name: 'ECDSA', namedCurve: 'P-521' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ECDH-ES':\n                case 'ECDH-ES+A128KW':\n                case 'ECDH-ES+A192KW':\n                case 'ECDH-ES+A256KW':\n                    algorithm = { name: 'ECDH', namedCurve: jwk.crv };\n                    keyUsages = jwk.d ? ['deriveBits'] : [];\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        case 'OKP': {\n            switch (jwk.alg) {\n                case 'Ed25519':\n                case 'EdDSA':\n                    algorithm = { name: 'Ed25519' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ECDH-ES':\n                case 'ECDH-ES+A128KW':\n                case 'ECDH-ES+A192KW':\n                case 'ECDH-ES+A256KW':\n                    algorithm = { name: jwk.crv };\n                    keyUsages = jwk.d ? ['deriveBits'] : [];\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        default:\n            throw new JOSENotSupported('Invalid or unsupported JWK \"kty\" (Key Type) Parameter value');\n    }\n    return { algorithm, keyUsages };\n}\nexport default async (jwk) => {\n    if (!jwk.alg) {\n        throw new TypeError('\"alg\" argument is required when \"jwk.alg\" is not present');\n    }\n    const { algorithm, keyUsages } = subtleMapping(jwk);\n    const keyData = { ...jwk };\n    if (keyData.kty !== 'AKP') {\n        delete keyData.alg;\n    }\n    delete keyData.use;\n    return crypto.subtle.importKey('jwk', keyData, algorithm, jwk.ext ?? (jwk.d || jwk.priv ? false : true), jwk.key_ops ?? keyUsages);\n};\n","import { isJWK } from './is_jwk.js';\nimport { decode } from '../util/base64url.js';\nimport importJWK from './jwk_to_key.js';\nimport { isCryptoKey, isKeyObject } from './is_key_like.js';\nlet cache;\nconst handleJWK = async (key, jwk, alg, freeze = false) => {\n    cache ||= new WeakMap();\n    let cached = cache.get(key);\n    if (cached?.[alg]) {\n        return cached[alg];\n    }\n    const cryptoKey = await importJWK({ ...jwk, alg });\n    if (freeze)\n        Object.freeze(key);\n    if (!cached) {\n        cache.set(key, { [alg]: cryptoKey });\n    }\n    else {\n        cached[alg] = cryptoKey;\n    }\n    return cryptoKey;\n};\nconst handleKeyObject = (keyObject, alg) => {\n    cache ||= new WeakMap();\n    let cached = cache.get(keyObject);\n    if (cached?.[alg]) {\n        return cached[alg];\n    }\n    const isPublic = keyObject.type === 'public';\n    const extractable = isPublic ? true : false;\n    let cryptoKey;\n    if (keyObject.asymmetricKeyType === 'x25519') {\n        switch (alg) {\n            case 'ECDH-ES':\n            case 'ECDH-ES+A128KW':\n            case 'ECDH-ES+A192KW':\n            case 'ECDH-ES+A256KW':\n                break;\n            default:\n                throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n        }\n        cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, isPublic ? [] : ['deriveBits']);\n    }\n    if (keyObject.asymmetricKeyType === 'ed25519') {\n        if (alg !== 'EdDSA' && alg !== 'Ed25519') {\n            throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n        }\n        cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, [\n            isPublic ? 'verify' : 'sign',\n        ]);\n    }\n    switch (keyObject.asymmetricKeyType) {\n        case 'ml-dsa-44':\n        case 'ml-dsa-65':\n        case 'ml-dsa-87': {\n            if (alg !== keyObject.asymmetricKeyType.toUpperCase()) {\n                throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n            }\n            cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, [\n                isPublic ? 'verify' : 'sign',\n            ]);\n        }\n    }\n    if (keyObject.asymmetricKeyType === 'rsa') {\n        let hash;\n        switch (alg) {\n            case 'RSA-OAEP':\n                hash = 'SHA-1';\n                break;\n            case 'RS256':\n            case 'PS256':\n            case 'RSA-OAEP-256':\n                hash = 'SHA-256';\n                break;\n            case 'RS384':\n            case 'PS384':\n            case 'RSA-OAEP-384':\n                hash = 'SHA-384';\n                break;\n            case 'RS512':\n            case 'PS512':\n            case 'RSA-OAEP-512':\n                hash = 'SHA-512';\n                break;\n            default:\n                throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n        }\n        if (alg.startsWith('RSA-OAEP')) {\n            return keyObject.toCryptoKey({\n                name: 'RSA-OAEP',\n                hash,\n            }, extractable, isPublic ? ['encrypt'] : ['decrypt']);\n        }\n        cryptoKey = keyObject.toCryptoKey({\n            name: alg.startsWith('PS') ? 'RSA-PSS' : 'RSASSA-PKCS1-v1_5',\n            hash,\n        }, extractable, [isPublic ? 'verify' : 'sign']);\n    }\n    if (keyObject.asymmetricKeyType === 'ec') {\n        const nist = new Map([\n            ['prime256v1', 'P-256'],\n            ['secp384r1', 'P-384'],\n            ['secp521r1', 'P-521'],\n        ]);\n        const namedCurve = nist.get(keyObject.asymmetricKeyDetails?.namedCurve);\n        if (!namedCurve) {\n            throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n        }\n        if (alg === 'ES256' && namedCurve === 'P-256') {\n            cryptoKey = keyObject.toCryptoKey({\n                name: 'ECDSA',\n                namedCurve,\n            }, extractable, [isPublic ? 'verify' : 'sign']);\n        }\n        if (alg === 'ES384' && namedCurve === 'P-384') {\n            cryptoKey = keyObject.toCryptoKey({\n                name: 'ECDSA',\n                namedCurve,\n            }, extractable, [isPublic ? 'verify' : 'sign']);\n        }\n        if (alg === 'ES512' && namedCurve === 'P-521') {\n            cryptoKey = keyObject.toCryptoKey({\n                name: 'ECDSA',\n                namedCurve,\n            }, extractable, [isPublic ? 'verify' : 'sign']);\n        }\n        if (alg.startsWith('ECDH-ES')) {\n            cryptoKey = keyObject.toCryptoKey({\n                name: 'ECDH',\n                namedCurve,\n            }, extractable, isPublic ? [] : ['deriveBits']);\n        }\n    }\n    if (!cryptoKey) {\n        throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n    }\n    if (!cached) {\n        cache.set(keyObject, { [alg]: cryptoKey });\n    }\n    else {\n        cached[alg] = cryptoKey;\n    }\n    return cryptoKey;\n};\nexport default async (key, alg) => {\n    if (key instanceof Uint8Array) {\n        return key;\n    }\n    if (isCryptoKey(key)) {\n        return key;\n    }\n    if (isKeyObject(key)) {\n        if (key.type === 'secret') {\n            return key.export();\n        }\n        if ('toCryptoKey' in key && typeof key.toCryptoKey === 'function') {\n            try {\n                return handleKeyObject(key, alg);\n            }\n            catch (err) {\n                if (err instanceof TypeError) {\n                    throw err;\n                }\n            }\n        }\n        let jwk = key.export({ format: 'jwk' });\n        return handleJWK(key, jwk, alg);\n    }\n    if (isJWK(key)) {\n        if (key.k) {\n            return decode(key.k);\n        }\n        return handleJWK(key, key, alg, true);\n    }\n    throw new Error('unreachable');\n};\n","import { encode as b64u } from '../../util/base64url.js';\nimport sign from '../../lib/sign.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport { JWSInvalid } from '../../util/errors.js';\nimport { encoder, decoder, concat } from '../../lib/buffer_utils.js';\nimport checkKeyType from '../../lib/check_key_type.js';\nimport validateCrit from '../../lib/validate_crit.js';\nimport normalizeKey from '../../lib/normalize_key.js';\nexport class FlattenedSign {\n    #payload;\n    #protectedHeader;\n    #unprotectedHeader;\n    constructor(payload) {\n        if (!(payload instanceof Uint8Array)) {\n            throw new TypeError('payload must be an instance of Uint8Array');\n        }\n        this.#payload = payload;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this.#protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this.#protectedHeader = protectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this.#unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this.#unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        if (!this.#protectedHeader && !this.#unprotectedHeader) {\n            throw new JWSInvalid('either setProtectedHeader or setUnprotectedHeader must be called before #sign()');\n        }\n        if (!isDisjoint(this.#protectedHeader, this.#unprotectedHeader)) {\n            throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n        }\n        const joseHeader = {\n            ...this.#protectedHeader,\n            ...this.#unprotectedHeader,\n        };\n        const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options?.crit, this.#protectedHeader, joseHeader);\n        let b64 = true;\n        if (extensions.has('b64')) {\n            b64 = this.#protectedHeader.b64;\n            if (typeof b64 !== 'boolean') {\n                throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n            }\n        }\n        const { alg } = joseHeader;\n        if (typeof alg !== 'string' || !alg) {\n            throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n        }\n        checkKeyType(alg, key, 'sign');\n        let payload = this.#payload;\n        if (b64) {\n            payload = encoder.encode(b64u(payload));\n        }\n        let protectedHeader;\n        if (this.#protectedHeader) {\n            protectedHeader = encoder.encode(b64u(JSON.stringify(this.#protectedHeader)));\n        }\n        else {\n            protectedHeader = encoder.encode('');\n        }\n        const data = concat(protectedHeader, encoder.encode('.'), payload);\n        const k = await normalizeKey(key, alg);\n        const signature = await sign(alg, k, data);\n        const jws = {\n            signature: b64u(signature),\n            payload: '',\n        };\n        if (b64) {\n            jws.payload = decoder.decode(payload);\n        }\n        if (this.#unprotectedHeader) {\n            jws.header = this.#unprotectedHeader;\n        }\n        if (this.#protectedHeader) {\n            jws.protected = decoder.decode(protectedHeader);\n        }\n        return jws;\n    }\n}\n","import { FlattenedSign } from '../flattened/sign.js';\nexport class CompactSign {\n    #flattened;\n    constructor(payload) {\n        this.#flattened = new FlattenedSign(payload);\n    }\n    setProtectedHeader(protectedHeader) {\n        this.#flattened.setProtectedHeader(protectedHeader);\n        return this;\n    }\n    async sign(key, options) {\n        const jws = await this.#flattened.sign(key, options);\n        if (jws.payload === undefined) {\n            throw new TypeError('use the flattened module for creating JWS with b64: false');\n        }\n        return `${jws.protected}.${jws.payload}.${jws.signature}`;\n    }\n}\n","export default (date) => Math.floor(date.getTime() / 1000);\n","const minute = 60;\nconst hour = minute * 60;\nconst day = hour * 24;\nconst week = day * 7;\nconst year = day * 365.25;\nconst REGEX = /^(\\+|\\-)? ?(\\d+|\\d+\\.\\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;\nexport default (str) => {\n    const matched = REGEX.exec(str);\n    if (!matched || (matched[4] && matched[1])) {\n        throw new TypeError('Invalid time period format');\n    }\n    const value = parseFloat(matched[2]);\n    const unit = matched[3].toLowerCase();\n    let numericDate;\n    switch (unit) {\n        case 'sec':\n        case 'secs':\n        case 'second':\n        case 'seconds':\n        case 's':\n            numericDate = Math.round(value);\n            break;\n        case 'minute':\n        case 'minutes':\n        case 'min':\n        case 'mins':\n        case 'm':\n            numericDate = Math.round(value * minute);\n            break;\n        case 'hour':\n        case 'hours':\n        case 'hr':\n        case 'hrs':\n        case 'h':\n            numericDate = Math.round(value * hour);\n            break;\n        case 'day':\n        case 'days':\n        case 'd':\n            numericDate = Math.round(value * day);\n            break;\n        case 'week':\n        case 'weeks':\n        case 'w':\n            numericDate = Math.round(value * week);\n            break;\n        default:\n            numericDate = Math.round(value * year);\n            break;\n    }\n    if (matched[1] === '-' || matched[4] === 'ago') {\n        return -numericDate;\n    }\n    return numericDate;\n};\n","import { JWTClaimValidationFailed, JWTExpired, JWTInvalid } from '../util/errors.js';\nimport { decoder } from './buffer_utils.js';\nimport epoch from './epoch.js';\nimport secs from './secs.js';\nimport isObject from './is_object.js';\nimport { encoder } from './buffer_utils.js';\nfunction validateInput(label, input) {\n    if (!Number.isFinite(input)) {\n        throw new TypeError(`Invalid ${label} input`);\n    }\n    return input;\n}\nconst normalizeTyp = (value) => {\n    if (value.includes('/')) {\n        return value.toLowerCase();\n    }\n    return `application/${value.toLowerCase()}`;\n};\nconst checkAudiencePresence = (audPayload, audOption) => {\n    if (typeof audPayload === 'string') {\n        return audOption.includes(audPayload);\n    }\n    if (Array.isArray(audPayload)) {\n        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));\n    }\n    return false;\n};\nexport function validateClaimsSet(protectedHeader, encodedPayload, options = {}) {\n    let payload;\n    try {\n        payload = JSON.parse(decoder.decode(encodedPayload));\n    }\n    catch {\n    }\n    if (!isObject(payload)) {\n        throw new JWTInvalid('JWT Claims Set must be a top-level JSON object');\n    }\n    const { typ } = options;\n    if (typ &&\n        (typeof protectedHeader.typ !== 'string' ||\n            normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {\n        throw new JWTClaimValidationFailed('unexpected \"typ\" JWT header value', payload, 'typ', 'check_failed');\n    }\n    const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;\n    const presenceCheck = [...requiredClaims];\n    if (maxTokenAge !== undefined)\n        presenceCheck.push('iat');\n    if (audience !== undefined)\n        presenceCheck.push('aud');\n    if (subject !== undefined)\n        presenceCheck.push('sub');\n    if (issuer !== undefined)\n        presenceCheck.push('iss');\n    for (const claim of new Set(presenceCheck.reverse())) {\n        if (!(claim in payload)) {\n            throw new JWTClaimValidationFailed(`missing required \"${claim}\" claim`, payload, claim, 'missing');\n        }\n    }\n    if (issuer &&\n        !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {\n        throw new JWTClaimValidationFailed('unexpected \"iss\" claim value', payload, 'iss', 'check_failed');\n    }\n    if (subject && payload.sub !== subject) {\n        throw new JWTClaimValidationFailed('unexpected \"sub\" claim value', payload, 'sub', 'check_failed');\n    }\n    if (audience &&\n        !checkAudiencePresence(payload.aud, typeof audience === 'string' ? [audience] : audience)) {\n        throw new JWTClaimValidationFailed('unexpected \"aud\" claim value', payload, 'aud', 'check_failed');\n    }\n    let tolerance;\n    switch (typeof options.clockTolerance) {\n        case 'string':\n            tolerance = secs(options.clockTolerance);\n            break;\n        case 'number':\n            tolerance = options.clockTolerance;\n            break;\n        case 'undefined':\n            tolerance = 0;\n            break;\n        default:\n            throw new TypeError('Invalid clockTolerance option type');\n    }\n    const { currentDate } = options;\n    const now = epoch(currentDate || new Date());\n    if ((payload.iat !== undefined || maxTokenAge) && typeof payload.iat !== 'number') {\n        throw new JWTClaimValidationFailed('\"iat\" claim must be a number', payload, 'iat', 'invalid');\n    }\n    if (payload.nbf !== undefined) {\n        if (typeof payload.nbf !== 'number') {\n            throw new JWTClaimValidationFailed('\"nbf\" claim must be a number', payload, 'nbf', 'invalid');\n        }\n        if (payload.nbf > now + tolerance) {\n            throw new JWTClaimValidationFailed('\"nbf\" claim timestamp check failed', payload, 'nbf', 'check_failed');\n        }\n    }\n    if (payload.exp !== undefined) {\n        if (typeof payload.exp !== 'number') {\n            throw new JWTClaimValidationFailed('\"exp\" claim must be a number', payload, 'exp', 'invalid');\n        }\n        if (payload.exp <= now - tolerance) {\n            throw new JWTExpired('\"exp\" claim timestamp check failed', payload, 'exp', 'check_failed');\n        }\n    }\n    if (maxTokenAge) {\n        const age = now - payload.iat;\n        const max = typeof maxTokenAge === 'number' ? maxTokenAge : secs(maxTokenAge);\n        if (age - tolerance > max) {\n            throw new JWTExpired('\"iat\" claim timestamp check failed (too far in the past)', payload, 'iat', 'check_failed');\n        }\n        if (age < 0 - tolerance) {\n            throw new JWTClaimValidationFailed('\"iat\" claim timestamp check failed (it should be in the past)', payload, 'iat', 'check_failed');\n        }\n    }\n    return payload;\n}\nexport class JWTClaimsBuilder {\n    #payload;\n    constructor(payload) {\n        if (!isObject(payload)) {\n            throw new TypeError('JWT Claims Set MUST be an object');\n        }\n        this.#payload = structuredClone(payload);\n    }\n    data() {\n        return encoder.encode(JSON.stringify(this.#payload));\n    }\n    get iss() {\n        return this.#payload.iss;\n    }\n    set iss(value) {\n        this.#payload.iss = value;\n    }\n    get sub() {\n        return this.#payload.sub;\n    }\n    set sub(value) {\n        this.#payload.sub = value;\n    }\n    get aud() {\n        return this.#payload.aud;\n    }\n    set aud(value) {\n        this.#payload.aud = value;\n    }\n    set jti(value) {\n        this.#payload.jti = value;\n    }\n    set nbf(value) {\n        if (typeof value === 'number') {\n            this.#payload.nbf = validateInput('setNotBefore', value);\n        }\n        else if (value instanceof Date) {\n            this.#payload.nbf = validateInput('setNotBefore', epoch(value));\n        }\n        else {\n            this.#payload.nbf = epoch(new Date()) + secs(value);\n        }\n    }\n    set exp(value) {\n        if (typeof value === 'number') {\n            this.#payload.exp = validateInput('setExpirationTime', value);\n        }\n        else if (value instanceof Date) {\n            this.#payload.exp = validateInput('setExpirationTime', epoch(value));\n        }\n        else {\n            this.#payload.exp = epoch(new Date()) + secs(value);\n        }\n    }\n    set iat(value) {\n        if (typeof value === 'undefined') {\n            this.#payload.iat = epoch(new Date());\n        }\n        else if (value instanceof Date) {\n            this.#payload.iat = validateInput('setIssuedAt', epoch(value));\n        }\n        else if (typeof value === 'string') {\n            this.#payload.iat = validateInput('setIssuedAt', epoch(new Date()) + secs(value));\n        }\n        else {\n            this.#payload.iat = validateInput('setIssuedAt', value);\n        }\n    }\n}\n","import { CompactSign } from '../jws/compact/sign.js';\nimport { JWTInvalid } from '../util/errors.js';\nimport { JWTClaimsBuilder } from '../lib/jwt_claims_set.js';\nexport class SignJWT {\n    #protectedHeader;\n    #jwt;\n    constructor(payload = {}) {\n        this.#jwt = new JWTClaimsBuilder(payload);\n    }\n    setIssuer(issuer) {\n        this.#jwt.iss = issuer;\n        return this;\n    }\n    setSubject(subject) {\n        this.#jwt.sub = subject;\n        return this;\n    }\n    setAudience(audience) {\n        this.#jwt.aud = audience;\n        return this;\n    }\n    setJti(jwtId) {\n        this.#jwt.jti = jwtId;\n        return this;\n    }\n    setNotBefore(input) {\n        this.#jwt.nbf = input;\n        return this;\n    }\n    setExpirationTime(input) {\n        this.#jwt.exp = input;\n        return this;\n    }\n    setIssuedAt(input) {\n        this.#jwt.iat = input;\n        return this;\n    }\n    setProtectedHeader(protectedHeader) {\n        this.#protectedHeader = protectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        const sig = new CompactSign(this.#jwt.data());\n        sig.setProtectedHeader(this.#protectedHeader);\n        if (Array.isArray(this.#protectedHeader?.crit) &&\n            this.#protectedHeader.crit.includes('b64') &&\n            this.#protectedHeader.b64 === false) {\n            throw new JWTInvalid('JWTs MUST NOT use unencoded payload');\n        }\n        return sig.sign(key, options);\n    }\n}\n","import { SignJWT, importPKCS8 } from 'jose';\nconst payload = (issuerId, duration)=>({\n        audience: 'appstoreconnect-v1',\n        expiresIn: duration,\n        issuer: issuerId\n    });\n/**\n * Synchronous token generation.\n * @deprecated Use `token` instead.\n * \n * @param privateKey\n * @param issuerId \n * @param privateKeyId \n * @param duration \n * @returns \n */ export function tokenSync(privateKey, issuerId, privateKeyId, duration = 500) {\n    let result;\n    token(privateKey, issuerId, privateKeyId, duration).then((token)=>{\n        result = token;\n        return token;\n    }).catch((error)=>{\n        throw new Error(`Failed to generate token: ${error.message}`);\n    });\n    return result ?? '';\n}\n/**\n * Asynchronous token generation.\n * @param privateKey \n * @param issuerId \n * @param privateKeyId \n * @param duration \n * @returns \n */ export async function token(privateKey, issuerId, privateKeyId, duration = 500) {\n    try {\n        const key = await importPKCS8(privateKey.toString(), 'ES256');\n        return new SignJWT(payload(issuerId, duration)).setProtectedHeader({\n            alg: 'ES256',\n            kid: privateKeyId\n        }).sign(key);\n    } catch (error) {\n        if (error instanceof Error) {\n            // Use predefined error messages to avoid information leakage\n            if (error.message.includes('PKCS8')) {\n                throw new Error('JWT token generation failed: Invalid key format');\n            } else if (error.message.includes('sign')) {\n                throw new Error('JWT token generation failed: Signing operation failed');\n            }\n            throw new Error('JWT token generation failed: Internal error');\n        }\n        throw new Error('JWT token generation failed: Unknown error occurred');\n    }\n}\nconst jwtGenCore = {\n    tokenSync,\n    token\n};\nexport default jwtGenCore;\n\n","import { token } from 'appstore-connect-jwt-generator-core';\nimport 'source-map-support/register';\nconst main = {\n    main: () => {\n        console.log(typeof token);\n    }\n};\nexport default main;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5tanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvbWFpbi5tdHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLHFDQUFxQyxDQUFDO0FBQzVELE9BQU8sNkJBQTZCLENBQUM7QUFFckMsTUFBTSxJQUFJLEdBQUc7SUFDVCxJQUFJLEVBQUUsR0FBRyxFQUFFO1FBQ1AsT0FBTyxDQUFDLEdBQUcsQ0FBQyxPQUFPLEtBQUssQ0FBQyxDQUFDO0lBQzlCLENBQUM7Q0FDSixDQUFDO0FBRUYsZUFBZSxJQUFJLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB0b2tlbiB9IGZyb20gJ2FwcHN0b3JlLWNvbm5lY3Qtand0LWdlbmVyYXRvci1jb3JlJztcbmltcG9ydCAnc291cmNlLW1hcC1zdXBwb3J0L3JlZ2lzdGVyJztcblxuY29uc3QgbWFpbiA9IHtcbiAgICBtYWluOiAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKHR5cGVvZiB0b2tlbik7XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgbWFpbjsiXX0="],"mappings":"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","ignoreList":[]}