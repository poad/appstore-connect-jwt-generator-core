import './sourcemap-register.cjs';var __webpack_modules__={359:module=>{module.exports=eval("require")("source-map-support/register")}};var __webpack_module_cache__={};function __nccwpck_require__(e){var t=__webpack_module_cache__[e];if(t!==undefined){return t.exports}var r=__webpack_module_cache__[e]={exports:{}};var a=true;try{__webpack_modules__[e](r,r.exports,__nccwpck_require__);a=false}finally{if(a)delete __webpack_module_cache__[e]}return r.exports}(()=>{__nccwpck_require__.d=(e,t)=>{for(var r in t){if(__nccwpck_require__.o(t,r)&&!__nccwpck_require__.o(e,r)){Object.defineProperty(e,r,{enumerable:true,get:t[r]})}}}})();(()=>{__nccwpck_require__.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)})();if(typeof __nccwpck_require__!=="undefined")__nccwpck_require__.ab=new URL(".",import.meta.url).pathname.slice(import.meta.url.match(/^file:\/\/\/\w:/)?1:0,-1)+"/";var __webpack_exports__={};__nccwpck_require__.d(__webpack_exports__,{A:()=>esm_main});function base64_encodeBase64(e){if(Uint8Array.prototype.toBase64){return e.toBase64()}const t=32768;const r=[];for(let a=0;a<e.length;a+=t){r.push(String.fromCharCode.apply(null,e.subarray(a,a+t)))}return btoa(r.join(""))}function decodeBase64(e){if(Uint8Array.fromBase64){return Uint8Array.fromBase64(e)}const t=atob(e);const r=new Uint8Array(t.length);for(let e=0;e<t.length;e++){r[e]=t.charCodeAt(e)}return r}class JOSEError extends Error{static code="ERR_JOSE_GENERIC";code="ERR_JOSE_GENERIC";constructor(e,t){super(e,t);this.name=this.constructor.name;Error.captureStackTrace?.(this,this.constructor)}}class errors_JWTClaimValidationFailed extends JOSEError{static code="ERR_JWT_CLAIM_VALIDATION_FAILED";code="ERR_JWT_CLAIM_VALIDATION_FAILED";claim;reason;payload;constructor(e,t,r="unspecified",a="unspecified"){super(e,{cause:{claim:r,reason:a,payload:t}});this.claim=r;this.reason=a;this.payload=t}}class errors_JWTExpired extends JOSEError{static code="ERR_JWT_EXPIRED";code="ERR_JWT_EXPIRED";claim;reason;payload;constructor(e,t,r="unspecified",a="unspecified"){super(e,{cause:{claim:r,reason:a,payload:t}});this.claim=r;this.reason=a;this.payload=t}}class JOSEAlgNotAllowed extends(null&&JOSEError){static code=null&&"ERR_JOSE_ALG_NOT_ALLOWED";code="ERR_JOSE_ALG_NOT_ALLOWED"}class errors_JOSENotSupported extends JOSEError{static code="ERR_JOSE_NOT_SUPPORTED";code="ERR_JOSE_NOT_SUPPORTED"}class JWEDecryptionFailed extends JOSEError{static code="ERR_JWE_DECRYPTION_FAILED";code="ERR_JWE_DECRYPTION_FAILED";constructor(e="decryption operation failed",t){super(e,t)}}class JWEInvalid extends(null&&JOSEError){static code=null&&"ERR_JWE_INVALID";code="ERR_JWE_INVALID"}class JWSInvalid extends JOSEError{static code="ERR_JWS_INVALID";code="ERR_JWS_INVALID"}class errors_JWTInvalid extends JOSEError{static code="ERR_JWT_INVALID";code="ERR_JWT_INVALID"}class JWKInvalid extends(null&&JOSEError){static code=null&&"ERR_JWK_INVALID";code="ERR_JWK_INVALID"}class JWKSInvalid extends(null&&JOSEError){static code=null&&"ERR_JWKS_INVALID";code="ERR_JWKS_INVALID"}class JWKSNoMatchingKey extends JOSEError{static code="ERR_JWKS_NO_MATCHING_KEY";code="ERR_JWKS_NO_MATCHING_KEY";constructor(e="no applicable key found in the JSON Web Key Set",t){super(e,t)}}class JWKSMultipleMatchingKeys extends JOSEError{[Symbol.asyncIterator];static code="ERR_JWKS_MULTIPLE_MATCHING_KEYS";code="ERR_JWKS_MULTIPLE_MATCHING_KEYS";constructor(e="multiple matching keys found in the JSON Web Key Set",t){super(e,t)}}class JWKSTimeout extends JOSEError{static code="ERR_JWKS_TIMEOUT";code="ERR_JWKS_TIMEOUT";constructor(e="request timed out",t){super(e,t)}}class JWSSignatureVerificationFailed extends JOSEError{static code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED";code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED";constructor(e="signature verification failed",t){super(e,t)}}const formatPEM=(e,t)=>{const r=(e.match(/.{1,64}/g)||[]).join("\n");return`-----BEGIN ${t}-----\n${r}\n-----END ${t}-----`};const genericExport=async(e,t,r)=>{if(isKeyObject(r)){if(r.type!==e){throw new TypeError(`key is not a ${e} key`)}return r.export({format:"pem",type:t})}if(!isCryptoKey(r)){throw new TypeError(invalidKeyInput(r,"CryptoKey","KeyObject"))}if(!r.extractable){throw new TypeError("CryptoKey is not extractable")}if(r.type!==e){throw new TypeError(`key is not a ${e} key`)}return formatPEM(encodeBase64(new Uint8Array(await crypto.subtle.exportKey(t,r))),`${e.toUpperCase()} KEY`)};const toSPKI=e=>genericExport("public","spki",e);const toPKCS8=e=>genericExport("private","pkcs8",e);const bytesEqual=(e,t)=>{if(e.byteLength!==t.length)return false;for(let r=0;r<e.byteLength;r++){if(e[r]!==t[r])return false}return true};const createASN1State=e=>({data:e,pos:0});const parseLength=e=>{const t=e.data[e.pos++];if(t&128){const r=t&127;let a=0;for(let t=0;t<r;t++){a=a<<8|e.data[e.pos++]}return a}return t};const skipElement=(e,t=1)=>{if(t<=0)return;e.pos++;const r=parseLength(e);e.pos+=r;if(t>1){skipElement(e,t-1)}};const expectTag=(e,t,r)=>{if(e.data[e.pos++]!==t){throw new Error(r)}};const getSubarray=(e,t)=>{const r=e.data.subarray(e.pos,e.pos+t);e.pos+=t;return r};const parseAlgorithmOID=e=>{expectTag(e,6,"Expected algorithm OID");const t=parseLength(e);return getSubarray(e,t)};function parsePKCS8Header(e){expectTag(e,48,"Invalid PKCS#8 structure");parseLength(e);expectTag(e,2,"Expected version field");const t=parseLength(e);e.pos+=t;expectTag(e,48,"Expected algorithm identifier");const r=parseLength(e);const a=e.pos;return{algIdStart:a,algIdLength:r}}function parseSPKIHeader(e){expectTag(e,48,"Invalid SPKI structure");parseLength(e);expectTag(e,48,"Expected algorithm identifier");const t=parseLength(e);const r=e.pos;return{algIdStart:r,algIdLength:t}}const parseECAlgorithmIdentifier=e=>{const t=parseAlgorithmOID(e);if(bytesEqual(t,[43,101,110])){return"X25519"}if(!bytesEqual(t,[42,134,72,206,61,2,1])){throw new Error("Unsupported key algorithm")}expectTag(e,6,"Expected curve OID");const r=parseLength(e);const a=getSubarray(e,r);for(const{name:e,oid:t}of[{name:"P-256",oid:[42,134,72,206,61,3,1,7]},{name:"P-384",oid:[43,129,4,0,34]},{name:"P-521",oid:[43,129,4,0,35]}]){if(bytesEqual(a,t)){return e}}throw new Error("Unsupported named curve")};const genericImport=async(e,t,r,a)=>{let s;let n;const i=e==="spki";const getSigUsages=()=>i?["verify"]:["sign"];const getEncUsages=()=>i?["encrypt","wrapKey"]:["decrypt","unwrapKey"];switch(r){case"PS256":case"PS384":case"PS512":s={name:"RSA-PSS",hash:`SHA-${r.slice(-3)}`};n=getSigUsages();break;case"RS256":case"RS384":case"RS512":s={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${r.slice(-3)}`};n=getSigUsages();break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":s={name:"RSA-OAEP",hash:`SHA-${parseInt(r.slice(-3),10)||1}`};n=getEncUsages();break;case"ES256":case"ES384":case"ES512":{const e={ES256:"P-256",ES384:"P-384",ES512:"P-521"};s={name:"ECDSA",namedCurve:e[r]};n=getSigUsages();break}case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{try{const e=a.getNamedCurve(t);s=e==="X25519"?{name:"X25519"}:{name:"ECDH",namedCurve:e}}catch(e){throw new errors_JOSENotSupported("Invalid or unsupported key format")}n=i?[]:["deriveBits"];break}case"Ed25519":case"EdDSA":s={name:"Ed25519"};n=getSigUsages();break;case"ML-DSA-44":case"ML-DSA-65":case"ML-DSA-87":s={name:r};n=getSigUsages();break;default:throw new errors_JOSENotSupported('Invalid or unsupported "alg" (Algorithm) value')}return crypto.subtle.importKey(e,t,s,a?.extractable??(i?true:false),n)};const processPEMData=(e,t)=>decodeBase64(e.replace(t,""));const fromPKCS8=(e,t,r)=>{const a=processPEMData(e,/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g);let s=r;if(t?.startsWith?.("ECDH-ES")){s||={};s.getNamedCurve=e=>{const t=createASN1State(e);parsePKCS8Header(t);return parseECAlgorithmIdentifier(t)}}return genericImport("pkcs8",a,t,s)};const asn1_fromSPKI=(e,t,r)=>{const a=processPEMData(e,/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g);let s=r;if(t?.startsWith?.("ECDH-ES")){s||={};s.getNamedCurve=e=>{const t=createASN1State(e);parseSPKIHeader(t);return parseECAlgorithmIdentifier(t)}}return genericImport("spki",a,t,s)};function spkiFromX509(e){const t=createASN1State(e);expectTag(t,48,"Invalid certificate structure");parseLength(t);expectTag(t,48,"Invalid tbsCertificate structure");parseLength(t);if(e[t.pos]===160){skipElement(t,6)}else{skipElement(t,5)}const r=t.pos;expectTag(t,48,"Invalid SPKI structure");const a=parseLength(t);return e.subarray(r,r+a+(t.pos-r))}function extractX509SPKI(e){const t=processPEMData(e,/(?:-----(?:BEGIN|END) CERTIFICATE-----|\s)/g);return spkiFromX509(t)}const asn1_fromX509=(e,t,r)=>{let a;try{a=extractX509SPKI(e)}catch(e){throw new TypeError("Failed to parse the X.509 certificate",{cause:e})}return asn1_fromSPKI(formatPEM(encodeBase64(a),"PUBLIC KEY"),t,r)};async function importSPKI(e,t,r){if(typeof e!=="string"||e.indexOf("-----BEGIN PUBLIC KEY-----")!==0){throw new TypeError('"spki" must be SPKI formatted string')}return fromSPKI(e,t,r)}async function importX509(e,t,r){if(typeof e!=="string"||e.indexOf("-----BEGIN CERTIFICATE-----")!==0){throw new TypeError('"x509" must be X.509 formatted string')}return fromX509(e,t,r)}async function importPKCS8(e,t,r){if(typeof e!=="string"||e.indexOf("-----BEGIN PRIVATE KEY-----")!==0){throw new TypeError('"pkcs8" must be PKCS#8 formatted string')}return fromPKCS8(e,t,r)}async function importJWK(e,t,r){if(!isObject(e)){throw new TypeError("JWK must be an object")}let a;t??=e.alg;a??=r?.extractable??e.ext;switch(e.kty){case"oct":if(typeof e.k!=="string"||!e.k){throw new TypeError('missing "k" (Key Value) Parameter value')}return decodeBase64URL(e.k);case"RSA":if("oth"in e&&e.oth!==undefined){throw new JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported')}return toCryptoKey({...e,alg:t,ext:a});case"AKP":{if(typeof e.alg!=="string"||!e.alg){throw new TypeError('missing "alg" (Algorithm) Parameter value')}if(t!==undefined&&t!==e.alg){throw new TypeError("JWK alg and alg option value mismatch")}return toCryptoKey({...e,ext:a})}case"EC":case"OKP":return toCryptoKey({...e,alg:t,ext:a});default:throw new JOSENotSupported('Unsupported "kty" (Key Type) Parameter value')}}const encoder=new TextEncoder;const buffer_utils_decoder=new TextDecoder;const MAX_INT32=null&&2**32;function concat(...e){const t=e.reduce(((e,{length:t})=>e+t),0);const r=new Uint8Array(t);let a=0;for(const t of e){r.set(t,a);a+=t.length}return r}function writeUInt32BE(e,t,r){if(t<0||t>=MAX_INT32){throw new RangeError(`value must be >= 0 and <= ${MAX_INT32-1}. Received ${t}`)}e.set([t>>>24,t>>>16,t>>>8,t&255],r)}function uint64be(e){const t=Math.floor(e/MAX_INT32);const r=e%MAX_INT32;const a=new Uint8Array(8);writeUInt32BE(a,t,0);writeUInt32BE(a,r,4);return a}function uint32be(e){const t=new Uint8Array(4);writeUInt32BE(t,e);return t}function decode(e){if(Uint8Array.fromBase64){return Uint8Array.fromBase64(typeof e==="string"?e:buffer_utils_decoder.decode(e),{alphabet:"base64url"})}let t=e;if(t instanceof Uint8Array){t=buffer_utils_decoder.decode(t)}t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return decodeBase64(t)}catch{throw new TypeError("The input to be decoded is not correctly encoded.")}}function encode(e){let t=e;if(typeof t==="string"){t=encoder.encode(t)}if(Uint8Array.prototype.toBase64){return t.toBase64({alphabet:"base64url",omitPadding:true})}return base64_encodeBase64(t).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}const subtle_dsa=(e,t)=>{const r=`SHA-${e.slice(-3)}`;switch(e){case"HS256":case"HS384":case"HS512":return{hash:r,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:r,name:"RSA-PSS",saltLength:parseInt(e.slice(-3),10)>>3};case"RS256":case"RS384":case"RS512":return{hash:r,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:r,name:"ECDSA",namedCurve:t.namedCurve};case"Ed25519":case"EdDSA":return{name:"Ed25519"};case"ML-DSA-44":case"ML-DSA-65":case"ML-DSA-87":return{name:e};default:throw new errors_JOSENotSupported(`alg ${e} is not supported either by JOSE or your javascript runtime`)}};const check_key_length=(e,t)=>{if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:r}=t.algorithm;if(typeof r!=="number"||r<2048){throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}}};function unusable(e,t="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function isAlgorithm(e,t){return e.name===t}function getHashLength(e){return parseInt(e.name.slice(4),10)}function getNamedCurve(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}function checkUsage(e,t){if(t&&!e.usages.includes(t)){throw new TypeError(`CryptoKey does not support this operation, its usages must include ${t}.`)}}function checkSigCryptoKey(e,t,r){switch(t){case"HS256":case"HS384":case"HS512":{if(!isAlgorithm(e.algorithm,"HMAC"))throw unusable("HMAC");const r=parseInt(t.slice(2),10);const a=getHashLength(e.algorithm.hash);if(a!==r)throw unusable(`SHA-${r}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!isAlgorithm(e.algorithm,"RSASSA-PKCS1-v1_5"))throw unusable("RSASSA-PKCS1-v1_5");const r=parseInt(t.slice(2),10);const a=getHashLength(e.algorithm.hash);if(a!==r)throw unusable(`SHA-${r}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!isAlgorithm(e.algorithm,"RSA-PSS"))throw unusable("RSA-PSS");const r=parseInt(t.slice(2),10);const a=getHashLength(e.algorithm.hash);if(a!==r)throw unusable(`SHA-${r}`,"algorithm.hash");break}case"Ed25519":case"EdDSA":{if(!isAlgorithm(e.algorithm,"Ed25519"))throw unusable("Ed25519");break}case"ML-DSA-44":case"ML-DSA-65":case"ML-DSA-87":{if(!isAlgorithm(e.algorithm,t))throw unusable(t);break}case"ES256":case"ES384":case"ES512":{if(!isAlgorithm(e.algorithm,"ECDSA"))throw unusable("ECDSA");const r=getNamedCurve(t);const a=e.algorithm.namedCurve;if(a!==r)throw unusable(r,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}checkUsage(e,r)}function checkEncCryptoKey(e,t,r){switch(t){case"A128GCM":case"A192GCM":case"A256GCM":{if(!isAlgorithm(e.algorithm,"AES-GCM"))throw unusable("AES-GCM");const r=parseInt(t.slice(1,4),10);const a=e.algorithm.length;if(a!==r)throw unusable(r,"algorithm.length");break}case"A128KW":case"A192KW":case"A256KW":{if(!isAlgorithm(e.algorithm,"AES-KW"))throw unusable("AES-KW");const r=parseInt(t.slice(1,4),10);const a=e.algorithm.length;if(a!==r)throw unusable(r,"algorithm.length");break}case"ECDH":{switch(e.algorithm.name){case"ECDH":case"X25519":break;default:throw unusable("ECDH or X25519")}break}case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":if(!isAlgorithm(e.algorithm,"PBKDF2"))throw unusable("PBKDF2");break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":{if(!isAlgorithm(e.algorithm,"RSA-OAEP"))throw unusable("RSA-OAEP");const r=parseInt(t.slice(9),10)||1;const a=getHashLength(e.algorithm.hash);if(a!==r)throw unusable(`SHA-${r}`,"algorithm.hash");break}default:throw new TypeError("CryptoKey does not support this operation")}checkUsage(e,r)}function message(e,t,...r){r=r.filter(Boolean);if(r.length>2){const t=r.pop();e+=`one of type ${r.join(", ")}, or ${t}.`}else if(r.length===2){e+=`one of type ${r[0]} or ${r[1]}.`}else{e+=`of type ${r[0]}.`}if(t==null){e+=` Received ${t}`}else if(typeof t==="function"&&t.name){e+=` Received function ${t.name}`}else if(typeof t==="object"&&t!=null){if(t.constructor?.name){e+=` Received an instance of ${t.constructor.name}`}}return e}const invalid_key_input=(e,...t)=>message("Key must be ",e,...t);function withAlg(e,t,...r){return message(`Key for the ${e} algorithm must be `,t,...r)}const get_sign_verify_key=async(e,t,r)=>{if(t instanceof Uint8Array){if(!e.startsWith("HS")){throw new TypeError(invalid_key_input(t,"CryptoKey","KeyObject","JSON Web Key"))}return crypto.subtle.importKey("raw",t,{hash:`SHA-${e.slice(-3)}`,name:"HMAC"},false,[r])}checkSigCryptoKey(t,e,r);return t};const sign=async(e,t,r)=>{const a=await get_sign_verify_key(e,t,"sign");check_key_length(e,a);const s=await crypto.subtle.sign(subtle_dsa(e,a.algorithm),a,r);return new Uint8Array(s)};const is_disjoint=(...e)=>{const t=e.filter(Boolean);if(t.length===0||t.length===1){return true}let r;for(const e of t){const t=Object.keys(e);if(!r||r.size===0){r=new Set(t);continue}for(const e of t){if(r.has(e)){return false}r.add(e)}}return true};function assertCryptoKey(e){if(!is_key_like_isCryptoKey(e)){throw new Error("CryptoKey instance expected")}}function is_key_like_isCryptoKey(e){return e?.[Symbol.toStringTag]==="CryptoKey"}function is_key_like_isKeyObject(e){return e?.[Symbol.toStringTag]==="KeyObject"}const is_key_like=e=>is_key_like_isCryptoKey(e)||is_key_like_isKeyObject(e);function isObjectLike(e){return typeof e==="object"&&e!==null}const is_object=e=>{if(!isObjectLike(e)||Object.prototype.toString.call(e)!=="[object Object]"){return false}if(Object.getPrototypeOf(e)===null){return true}let t=e;while(Object.getPrototypeOf(t)!==null){t=Object.getPrototypeOf(t)}return Object.getPrototypeOf(e)===t};function isJWK(e){return is_object(e)&&typeof e.kty==="string"}function isPrivateJWK(e){return e.kty!=="oct"&&(e.kty==="AKP"&&typeof e.priv==="string"||typeof e.d==="string")}function isPublicJWK(e){return e.kty!=="oct"&&typeof e.d==="undefined"&&typeof e.priv==="undefined"}function isSecretJWK(e){return e.kty==="oct"&&typeof e.k==="string"}const tag=e=>e?.[Symbol.toStringTag];const jwkMatchesOp=(e,t,r)=>{if(t.use!==undefined){let e;switch(r){case"sign":case"verify":e="sig";break;case"encrypt":case"decrypt":e="enc";break}if(t.use!==e){throw new TypeError(`Invalid key for this operation, its "use" must be "${e}" when present`)}}if(t.alg!==undefined&&t.alg!==e){throw new TypeError(`Invalid key for this operation, its "alg" must be "${e}" when present`)}if(Array.isArray(t.key_ops)){let a;switch(true){case r==="sign"||r==="verify":case e==="dir":case e.includes("CBC-HS"):a=r;break;case e.startsWith("PBES2"):a="deriveBits";break;case/^A\d{3}(?:GCM)?(?:KW)?$/.test(e):if(!e.includes("GCM")&&e.endsWith("KW")){a=r==="encrypt"?"wrapKey":"unwrapKey"}else{a=r}break;case r==="encrypt"&&e.startsWith("RSA"):a="wrapKey";break;case r==="decrypt":a=e.startsWith("RSA")?"unwrapKey":"deriveBits";break}if(a&&t.key_ops?.includes?.(a)===false){throw new TypeError(`Invalid key for this operation, its "key_ops" must include "${a}" when present`)}}return true};const symmetricTypeCheck=(e,t,r)=>{if(t instanceof Uint8Array)return;if(isJWK(t)){if(isSecretJWK(t)&&jwkMatchesOp(e,t,r))return;throw new TypeError(`JSON Web Key for symmetric algorithms must have JWK "kty" (Key Type) equal to "oct" and the JWK "k" (Key Value) present`)}if(!is_key_like(t)){throw new TypeError(withAlg(e,t,"CryptoKey","KeyObject","JSON Web Key","Uint8Array"))}if(t.type!=="secret"){throw new TypeError(`${tag(t)} instances for symmetric algorithms must be of type "secret"`)}};const asymmetricTypeCheck=(e,t,r)=>{if(isJWK(t)){switch(r){case"decrypt":case"sign":if(isPrivateJWK(t)&&jwkMatchesOp(e,t,r))return;throw new TypeError(`JSON Web Key for this operation be a private JWK`);case"encrypt":case"verify":if(isPublicJWK(t)&&jwkMatchesOp(e,t,r))return;throw new TypeError(`JSON Web Key for this operation be a public JWK`)}}if(!is_key_like(t)){throw new TypeError(withAlg(e,t,"CryptoKey","KeyObject","JSON Web Key"))}if(t.type==="secret"){throw new TypeError(`${tag(t)} instances for asymmetric algorithms must not be of type "secret"`)}if(t.type==="public"){switch(r){case"sign":throw new TypeError(`${tag(t)} instances for asymmetric algorithm signing must be of type "private"`);case"decrypt":throw new TypeError(`${tag(t)} instances for asymmetric algorithm decryption must be of type "private"`);default:break}}if(t.type==="private"){switch(r){case"verify":throw new TypeError(`${tag(t)} instances for asymmetric algorithm verifying must be of type "public"`);case"encrypt":throw new TypeError(`${tag(t)} instances for asymmetric algorithm encryption must be of type "public"`);default:break}}};const check_key_type=(e,t,r)=>{const a=e.startsWith("HS")||e==="dir"||e.startsWith("PBES2")||/^A(?:128|192|256)(?:GCM)?(?:KW)?$/.test(e)||/^A(?:128|192|256)CBC-HS(?:256|384|512)$/.test(e);if(a){symmetricTypeCheck(e,t,r)}else{asymmetricTypeCheck(e,t,r)}};const validate_crit=(e,t,r,a,s)=>{if(s.crit!==undefined&&a?.crit===undefined){throw new e('"crit" (Critical) Header Parameter MUST be integrity protected')}if(!a||a.crit===undefined){return new Set}if(!Array.isArray(a.crit)||a.crit.length===0||a.crit.some((e=>typeof e!=="string"||e.length===0))){throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present')}let n;if(r!==undefined){n=new Map([...Object.entries(r),...t.entries()])}else{n=t}for(const t of a.crit){if(!n.has(t)){throw new errors_JOSENotSupported(`Extension Header Parameter "${t}" is not recognized`)}if(s[t]===undefined){throw new e(`Extension Header Parameter "${t}" is missing`)}if(n.get(t)&&a[t]===undefined){throw new e(`Extension Header Parameter "${t}" MUST be integrity protected`)}}return new Set(a.crit)};function subtleMapping(e){let t;let r;switch(e.kty){case"AKP":{switch(e.alg){case"ML-DSA-44":case"ML-DSA-65":case"ML-DSA-87":t={name:e.alg};r=e.priv?["sign"]:["verify"];break;default:throw new errors_JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case"RSA":{switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.slice(-3)}`};r=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.slice(-3)}`};r=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.slice(-3),10)||1}`};r=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new errors_JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case"EC":{switch(e.alg){case"ES256":t={name:"ECDSA",namedCurve:"P-256"};r=e.d?["sign"]:["verify"];break;case"ES384":t={name:"ECDSA",namedCurve:"P-384"};r=e.d?["sign"]:["verify"];break;case"ES512":t={name:"ECDSA",namedCurve:"P-521"};r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv};r=e.d?["deriveBits"]:[];break;default:throw new errors_JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case"OKP":{switch(e.alg){case"Ed25519":case"EdDSA":t={name:"Ed25519"};r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:e.crv};r=e.d?["deriveBits"]:[];break;default:throw new errors_JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}default:throw new errors_JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:r}}const jwk_to_key=async e=>{if(!e.alg){throw new TypeError('"alg" argument is required when "jwk.alg" is not present')}const{algorithm:t,keyUsages:r}=subtleMapping(e);const a={...e};if(a.kty!=="AKP"){delete a.alg}delete a.use;return crypto.subtle.importKey("jwk",a,t,e.ext??(e.d||e.priv?false:true),e.key_ops??r)};let cache;const handleJWK=async(e,t,r,a=false)=>{cache||=new WeakMap;let s=cache.get(e);if(s?.[r]){return s[r]}const n=await jwk_to_key({...t,alg:r});if(a)Object.freeze(e);if(!s){cache.set(e,{[r]:n})}else{s[r]=n}return n};const handleKeyObject=(e,t)=>{cache||=new WeakMap;let r=cache.get(e);if(r?.[t]){return r[t]}const a=e.type==="public";const s=a?true:false;let n;if(e.asymmetricKeyType==="x25519"){switch(t){case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":break;default:throw new TypeError("given KeyObject instance cannot be used for this algorithm")}n=e.toCryptoKey(e.asymmetricKeyType,s,a?[]:["deriveBits"])}if(e.asymmetricKeyType==="ed25519"){if(t!=="EdDSA"&&t!=="Ed25519"){throw new TypeError("given KeyObject instance cannot be used for this algorithm")}n=e.toCryptoKey(e.asymmetricKeyType,s,[a?"verify":"sign"])}switch(e.asymmetricKeyType){case"ml-dsa-44":case"ml-dsa-65":case"ml-dsa-87":{if(t!==e.asymmetricKeyType.toUpperCase()){throw new TypeError("given KeyObject instance cannot be used for this algorithm")}n=e.toCryptoKey(e.asymmetricKeyType,s,[a?"verify":"sign"])}}if(e.asymmetricKeyType==="rsa"){let r;switch(t){case"RSA-OAEP":r="SHA-1";break;case"RS256":case"PS256":case"RSA-OAEP-256":r="SHA-256";break;case"RS384":case"PS384":case"RSA-OAEP-384":r="SHA-384";break;case"RS512":case"PS512":case"RSA-OAEP-512":r="SHA-512";break;default:throw new TypeError("given KeyObject instance cannot be used for this algorithm")}if(t.startsWith("RSA-OAEP")){return e.toCryptoKey({name:"RSA-OAEP",hash:r},s,a?["encrypt"]:["decrypt"])}n=e.toCryptoKey({name:t.startsWith("PS")?"RSA-PSS":"RSASSA-PKCS1-v1_5",hash:r},s,[a?"verify":"sign"])}if(e.asymmetricKeyType==="ec"){const r=new Map([["prime256v1","P-256"],["secp384r1","P-384"],["secp521r1","P-521"]]);const i=r.get(e.asymmetricKeyDetails?.namedCurve);if(!i){throw new TypeError("given KeyObject instance cannot be used for this algorithm")}if(t==="ES256"&&i==="P-256"){n=e.toCryptoKey({name:"ECDSA",namedCurve:i},s,[a?"verify":"sign"])}if(t==="ES384"&&i==="P-384"){n=e.toCryptoKey({name:"ECDSA",namedCurve:i},s,[a?"verify":"sign"])}if(t==="ES512"&&i==="P-521"){n=e.toCryptoKey({name:"ECDSA",namedCurve:i},s,[a?"verify":"sign"])}if(t.startsWith("ECDH-ES")){n=e.toCryptoKey({name:"ECDH",namedCurve:i},s,a?[]:["deriveBits"])}}if(!n){throw new TypeError("given KeyObject instance cannot be used for this algorithm")}if(!r){cache.set(e,{[t]:n})}else{r[t]=n}return n};const normalize_key=async(e,t)=>{if(e instanceof Uint8Array){return e}if(is_key_like_isCryptoKey(e)){return e}if(is_key_like_isKeyObject(e)){if(e.type==="secret"){return e.export()}if("toCryptoKey"in e&&typeof e.toCryptoKey==="function"){try{return handleKeyObject(e,t)}catch(e){if(e instanceof TypeError){throw e}}}let r=e.export({format:"jwk"});return handleJWK(e,r,t)}if(isJWK(e)){if(e.k){return decode(e.k)}return handleJWK(e,e,t,true)}throw new Error("unreachable")};class FlattenedSign{#e;#t;#r;constructor(e){if(!(e instanceof Uint8Array)){throw new TypeError("payload must be an instance of Uint8Array")}this.#e=e}setProtectedHeader(e){if(this.#t){throw new TypeError("setProtectedHeader can only be called once")}this.#t=e;return this}setUnprotectedHeader(e){if(this.#r){throw new TypeError("setUnprotectedHeader can only be called once")}this.#r=e;return this}async sign(e,t){if(!this.#t&&!this.#r){throw new JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()")}if(!is_disjoint(this.#t,this.#r)){throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint")}const r={...this.#t,...this.#r};const a=validate_crit(JWSInvalid,new Map([["b64",true]]),t?.crit,this.#t,r);let s=true;if(a.has("b64")){s=this.#t.b64;if(typeof s!=="boolean"){throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean')}}const{alg:n}=r;if(typeof n!=="string"||!n){throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid')}check_key_type(n,e,"sign");let i=this.#e;if(s){i=encoder.encode(encode(i))}let o;if(this.#t){o=encoder.encode(encode(JSON.stringify(this.#t)))}else{o=encoder.encode("")}const c=concat(o,encoder.encode("."),i);const l=await normalize_key(e,n);const d=await sign(n,l,c);const u={signature:encode(d),payload:""};if(s){u.payload=buffer_utils_decoder.decode(i)}if(this.#r){u.header=this.#r}if(this.#t){u.protected=buffer_utils_decoder.decode(o)}return u}}class CompactSign{#a;constructor(e){this.#a=new FlattenedSign(e)}setProtectedHeader(e){this.#a.setProtectedHeader(e);return this}async sign(e,t){const r=await this.#a.sign(e,t);if(r.payload===undefined){throw new TypeError("use the flattened module for creating JWS with b64: false")}return`${r.protected}.${r.payload}.${r.signature}`}}const lib_epoch=e=>Math.floor(e.getTime()/1e3);const minute=60;const hour=minute*60;const day=hour*24;const week=day*7;const year=day*365.25;const REGEX=/^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;const lib_secs=e=>{const t=REGEX.exec(e);if(!t||t[4]&&t[1]){throw new TypeError("Invalid time period format")}const r=parseFloat(t[2]);const a=t[3].toLowerCase();let s;switch(a){case"sec":case"secs":case"second":case"seconds":case"s":s=Math.round(r);break;case"minute":case"minutes":case"min":case"mins":case"m":s=Math.round(r*minute);break;case"hour":case"hours":case"hr":case"hrs":case"h":s=Math.round(r*hour);break;case"day":case"days":case"d":s=Math.round(r*day);break;case"week":case"weeks":case"w":s=Math.round(r*week);break;default:s=Math.round(r*year);break}if(t[1]==="-"||t[4]==="ago"){return-s}return s};function validateInput(e,t){if(!Number.isFinite(t)){throw new TypeError(`Invalid ${e} input`)}return t}const normalizeTyp=e=>{if(e.includes("/")){return e.toLowerCase()}return`application/${e.toLowerCase()}`};const checkAudiencePresence=(e,t)=>{if(typeof e==="string"){return t.includes(e)}if(Array.isArray(e)){return t.some(Set.prototype.has.bind(new Set(e)))}return false};function validateClaimsSet(e,t,r={}){let a;try{a=JSON.parse(decoder.decode(t))}catch{}if(!isObject(a)){throw new JWTInvalid("JWT Claims Set must be a top-level JSON object")}const{typ:s}=r;if(s&&(typeof e.typ!=="string"||normalizeTyp(e.typ)!==normalizeTyp(s))){throw new JWTClaimValidationFailed('unexpected "typ" JWT header value',a,"typ","check_failed")}const{requiredClaims:n=[],issuer:i,subject:o,audience:c,maxTokenAge:l}=r;const d=[...n];if(l!==undefined)d.push("iat");if(c!==undefined)d.push("aud");if(o!==undefined)d.push("sub");if(i!==undefined)d.push("iss");for(const e of new Set(d.reverse())){if(!(e in a)){throw new JWTClaimValidationFailed(`missing required "${e}" claim`,a,e,"missing")}}if(i&&!(Array.isArray(i)?i:[i]).includes(a.iss)){throw new JWTClaimValidationFailed('unexpected "iss" claim value',a,"iss","check_failed")}if(o&&a.sub!==o){throw new JWTClaimValidationFailed('unexpected "sub" claim value',a,"sub","check_failed")}if(c&&!checkAudiencePresence(a.aud,typeof c==="string"?[c]:c)){throw new JWTClaimValidationFailed('unexpected "aud" claim value',a,"aud","check_failed")}let u;switch(typeof r.clockTolerance){case"string":u=secs(r.clockTolerance);break;case"number":u=r.clockTolerance;break;case"undefined":u=0;break;default:throw new TypeError("Invalid clockTolerance option type")}const{currentDate:p}=r;const h=epoch(p||new Date);if((a.iat!==undefined||l)&&typeof a.iat!=="number"){throw new JWTClaimValidationFailed('"iat" claim must be a number',a,"iat","invalid")}if(a.nbf!==undefined){if(typeof a.nbf!=="number"){throw new JWTClaimValidationFailed('"nbf" claim must be a number',a,"nbf","invalid")}if(a.nbf>h+u){throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed',a,"nbf","check_failed")}}if(a.exp!==undefined){if(typeof a.exp!=="number"){throw new JWTClaimValidationFailed('"exp" claim must be a number',a,"exp","invalid")}if(a.exp<=h-u){throw new JWTExpired('"exp" claim timestamp check failed',a,"exp","check_failed")}}if(l){const e=h-a.iat;const t=typeof l==="number"?l:secs(l);if(e-u>t){throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)',a,"iat","check_failed")}if(e<0-u){throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)',a,"iat","check_failed")}}return a}class JWTClaimsBuilder{#e;constructor(e){if(!is_object(e)){throw new TypeError("JWT Claims Set MUST be an object")}this.#e=structuredClone(e)}data(){return encoder.encode(JSON.stringify(this.#e))}get iss(){return this.#e.iss}set iss(e){this.#e.iss=e}get sub(){return this.#e.sub}set sub(e){this.#e.sub=e}get aud(){return this.#e.aud}set aud(e){this.#e.aud=e}set jti(e){this.#e.jti=e}set nbf(e){if(typeof e==="number"){this.#e.nbf=validateInput("setNotBefore",e)}else if(e instanceof Date){this.#e.nbf=validateInput("setNotBefore",lib_epoch(e))}else{this.#e.nbf=lib_epoch(new Date)+lib_secs(e)}}set exp(e){if(typeof e==="number"){this.#e.exp=validateInput("setExpirationTime",e)}else if(e instanceof Date){this.#e.exp=validateInput("setExpirationTime",lib_epoch(e))}else{this.#e.exp=lib_epoch(new Date)+lib_secs(e)}}set iat(e){if(typeof e==="undefined"){this.#e.iat=lib_epoch(new Date)}else if(e instanceof Date){this.#e.iat=validateInput("setIssuedAt",lib_epoch(e))}else if(typeof e==="string"){this.#e.iat=validateInput("setIssuedAt",lib_epoch(new Date)+lib_secs(e))}else{this.#e.iat=validateInput("setIssuedAt",e)}}}class SignJWT{#t;#s;constructor(e={}){this.#s=new JWTClaimsBuilder(e)}setIssuer(e){this.#s.iss=e;return this}setSubject(e){this.#s.sub=e;return this}setAudience(e){this.#s.aud=e;return this}setJti(e){this.#s.jti=e;return this}setNotBefore(e){this.#s.nbf=e;return this}setExpirationTime(e){this.#s.exp=e;return this}setIssuedAt(e){this.#s.iat=e;return this}setProtectedHeader(e){this.#t=e;return this}async sign(e,t){const r=new CompactSign(this.#s.data());r.setProtectedHeader(this.#t);if(Array.isArray(this.#t?.crit)&&this.#t.crit.includes("b64")&&this.#t.b64===false){throw new errors_JWTInvalid("JWTs MUST NOT use unencoded payload")}return r.sign(e,t)}}const payload=(e,t)=>({audience:"appstoreconnect-v1",expiresIn:t,issuer:e});function tokenSync(e,t,r,a=500){let s;token(e,t,r,a).then((e=>{s=e;return e})).catch((e=>{throw new Error(`Failed to generate token: ${e.message}`)}));return s??""}async function token(e,t,r,a=500){const s=await importPKCS8(e.toString(),"ES256");return new SignJWT(payload(t,a)).setProtectedHeader({alg:"ES256",kid:r}).sign(s)}const jwtGenCore={tokenSync:tokenSync,token:token};const esm=null&&jwtGenCore;var register=__nccwpck_require__(359);const main={main:()=>{console.log(typeof token)}};const esm_main=main;var __webpack_exports__default=__webpack_exports__.A;export{__webpack_exports__default as default};
//# sourceMappingURL=index.mjs.map